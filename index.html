<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ツリーエディター</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #f5f5f5;
            height: 100vh;
            overflow: hidden;
            margin: 0;
            padding: 0;
        }
        
        .container {
            display: flex;
            height: 100vh;
            gap: 1px;
            background: #ddd;
        }
        
        .editor-pane {
            flex: 1;
            background: white;
            display: flex;
            flex-direction: column;
            min-width: 0; /* flexアイテムの縮小を許可 */
            position: relative;
        }
        
        .pane-header {
            background: #2c3e50;
            color: white;
            padding: 12px 16px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }
        
        .pane-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            position: relative;
        }
        
        /* メインタブのコンテンツエリア */
        .editor-pane:first-child .pane-content {
            overflow: hidden;
        }
        
        /* 同期スクロール用のコンテナ */
        .sync-scroll-pane {
            overflow-y: auto !important;
        }
        
        .sync-scroll-content {
            position: relative;
            padding-bottom: 50px;
        }
        
        .main-editor {
            width: 100%;
            height: 100%;
            border: none;
            padding: 16px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            line-height: 1.6;
            resize: none;
            overflow-y: auto;
        }
        
        /* 各要素の高さを統一するための基本スタイル */
        .sync-item {
            position: absolute;
            left: 0;
            right: 0;
            padding: 8px;
        }
        
        /* シーン要素のスタイル */
        .scene-item {
            background: #e8f0fe;
            border: 1px solid #dadce0;
            border-radius: 8px;
            padding: 12px;
            margin: 0 8px;
            width: calc(100% - 16px);
        }
        
        .scene-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .scene-label {
            background: #1a73e8;
            color: white;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }
        
        .scene-content {
            background: white;
            border: 1px solid #dadce0;
            border-radius: 4px;
            padding: 8px;
            min-height: 60px;
            white-space: pre-wrap;
            word-break: break-word;
            font-size: 14px;
            line-height: 1.6;
        }
        
        .scene-content:focus {
            outline: none;
            border-color: #1a73e8;
            box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.2);
        }
        
        /* contenteditable用の改行表示設定 */
        .scene-content br,
        .page-content br {
            display: block;
            content: "";
        }
        
        .scene-content:empty:before,
        .page-content:empty:before {
            content: attr(placeholder);
            color: #999;
        }
        
        /* ページ要素のスタイル */
        .page-item {
            background: #f8f9fa;
            border: 1px solid #dadce0;
            border-radius: 8px;
            padding: 12px;
            margin: 0 8px;
            width: calc(100% - 16px);
        }
        
        .page-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .page-label {
            background: #5f6368;
            color: white;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }
        
        .page-content {
            background: white;
            border: 1px solid #dadce0;
            border-radius: 4px;
            padding: 8px;
            min-height: 40px;
            white-space: pre-wrap;
            word-break: break-word;
            font-size: 14px;
            line-height: 1.6;
        }
        
        .page-content:focus {
            outline: none;
            border-color: #5f6368;
            box-shadow: 0 0 0 2px rgba(95, 99, 104, 0.2);
        }
        
        /* セリフ要素のスタイル */
        .dialogue-item {
            background: #fef7e0;
            border: 1px solid #f9ab00;
            border-radius: 8px;
            padding: 12px;
            margin: 0 8px;
            width: calc(100% - 16px);
        }
        
        .dialogue-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .dialogue-label {
            background: #f9ab00;
            color: #202124;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }
        
        .dialogue-content {
            background: white;
            border: 1px solid #f9ab00;
            border-radius: 4px;
            padding: 8px;
            color: #202124;
        }
        
        .dialogue-text {
            margin: 4px 0;
            padding: 4px 8px;
            background: #fffbf0;
            border-left: 3px solid #f9ab00;
            font-style: italic;
        }
        
        /* ボタンスタイル */
        .delete-button {
            background: #dc3545;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .delete-button:hover {
            background: #c82333;
        }
        
        .export-button {
            background: #6c757d;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .export-button:hover {
            background: #5a6268;
        }
        
        .add-button {
            background: #28a745;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .add-button:hover {
            background: #218838;
        }
        
        /* ページ追加ボタン */
        .add-page-button {
            position: absolute;
            left: 8px;
            right: 8px;
            background: #17a2b8;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            text-align: center;
        }
        
        .add-page-button:hover {
            background: #138496;
        }
        
        /* ドラッグ中のスタイル */
        .dragging {
            opacity: 0.5;
        }
        
        .drag-over {
            border-top: 3px solid #1a73e8;
        }
        
        /* レスポンシブ対応 */
        @media (max-width: 1200px) {
            .editor-pane {
                min-width: 200px;
            }
        }
        
        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            
            .editor-pane {
                min-width: unset;
                width: 100%;
            }
            
            /* モバイルでは最初のペインのみ表示 */
            .editor-pane:not(:first-child) {
                display: none;
            }
            
            .pane-header {
                position: sticky;
                top: 0;
                z-index: 100;
            }
            
            .main-editor {
                font-size: 16px; /* モバイルでの自動ズーム防止 */
            }
            
            /* ページ追加ボタンをモバイルで見やすく */
            .add-page-button {
                position: relative !important;
                margin: 10px 8px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- メインタブ -->
        <div class="editor-pane" id="mainPane">
            <div class="pane-header">
                <span>メインタブ</span>
                <div>
                    <button onclick="newFile()" class="export-button">新規作成</button>
                    <button onclick="openFile()" class="export-button">開く</button>
                    <button onclick="saveFile()" class="export-button">上書き保存</button>
                    <button onclick="undo()" class="export-button" title="元に戻す (Ctrl+Z)">↶</button>
                    <button onclick="redo()" class="export-button" title="やり直し (Ctrl+Y)">↷</button>
                </div>
            </div>
            <div class="pane-content" ondrop="handleFileDrop(event)" ondragover="handleDragOver(event)">
                <textarea id="mainEditor" class="main-editor" placeholder="ここにテキストを入力...

例:
{シーン: 朝の教室
生徒たちが登校してくる時間。
[ページ: 1ページ目
「おはよう！」
主人公が教室に入ってくる。
]
[ページ: 2ページ目
「今日も一日頑張ろう」
授業が始まる。
]
}

{シーン: 昼休み
[ページ: お弁当タイム
「お腹すいた～」
みんなでお弁当を食べる。
]
}"></textarea>
            </div>
        </div>
        
        <!-- シーンタブ -->
        <div class="editor-pane" id="scenesPane" style="display: none;">
            <div class="pane-header">
                <span>シーンタブ</span>
                <button onclick="addScene()" class="export-button">シーン追加</button>
            </div>
            <div class="pane-content sync-scroll-pane" id="scenesContainer">
                <div class="sync-scroll-content" id="scenesContent"></div>
            </div>
        </div>
        
        <!-- ページタブ -->
        <div class="editor-pane" id="pagesPane" style="display: none;">
            <div class="pane-header">
                <span>ページタブ</span>
                <button onclick="addPage()" class="export-button">ページ追加</button>
            </div>
            <div class="pane-content sync-scroll-pane" id="pagesContainer">
                <div class="sync-scroll-content" id="pagesContent"></div>
            </div>
        </div>
        
        <!-- セリフタブ -->
        <div class="editor-pane" id="dialoguesPane" style="display: none;">
            <div class="pane-header">
                <span>セリフタブ</span>
                <button onclick="exportDialogues()" class="export-button">エクスポート</button>
            </div>
            <div class="pane-content sync-scroll-pane" id="dialoguesContainer">
                <div class="sync-scroll-content" id="dialoguesContent"></div>
            </div>
        </div>
    </div>
    
    <!-- モバイルナビゲーション -->
    <nav class="mobile-nav">
        <div class="mobile-nav-items">
            <div class="mobile-nav-item active" onclick="switchTab('main')">
                <div>📝</div>
                <div>メイン</div>
            </div>
            <div class="mobile-nav-item" onclick="switchTab('scenes')">
                <div>🎬</div>
                <div>シーン</div>
            </div>
            <div class="mobile-nav-item" onclick="switchTab('pages')">
                <div>📄</div>
                <div>ページ</div>
            </div>
            <div class="mobile-nav-item" onclick="switchTab('dialogues')">
                <div>💬</div>
                <div>セリフ</div>
            </div>
        </div>
    </nav>

    <script>
        let data = {
            scenes: [],
            pages: [],
            dialogues: []
        };
        
        let draggedElement = null;
        let draggedType = null;
        let draggedIndex = null;
        
        // DOM要素の取得（後で初期化）
        let mainEditor;
        let scenesContent;
        let pagesContent;
        let dialoguesContent;
        let scenesContainer;
        let pagesContainer;
        let dialoguesContainer;
        
        // 履歴管理
        let history = [];
        let historyIndex = -1;
        const maxHistory = 50;
        
        // 履歴を追加
        function addToHistory(text) {
            // 現在位置より後の履歴を削除
            history = history.slice(0, historyIndex + 1);
            
            // 新しい履歴を追加
            history.push(text);
            
            // 最大履歴数を超えたら古いものを削除
            if (history.length > maxHistory) {
                history.shift();
            }
            
            historyIndex = history.length - 1;
        }
        
        // 元に戻す
        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                mainEditor.value = history[historyIndex];
                updateUI();
            }
        }
        
        // やり直し
        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                mainEditor.value = history[historyIndex];
                updateUI();
            }
        }
        
        // モバイルタブ切り替え
        let currentTab = 'main';
        
        function switchTab(tabName) {
            currentTab = tabName;
            
            // すべてのペインを非表示
            document.getElementById('mainPane').style.display = 'none';
            document.getElementById('scenesPane').style.display = 'none';
            document.getElementById('pagesPane').style.display = 'none';
            document.getElementById('dialoguesPane').style.display = 'none';
            
            // 選択されたペインを表示
            switch(tabName) {
                case 'main':
                    document.getElementById('mainPane').style.display = 'flex';
                    break;
                case 'scenes':
                    document.getElementById('scenesPane').style.display = 'flex';
                    break;
                case 'pages':
                    document.getElementById('pagesPane').style.display = 'flex';
                    break;
                case 'dialogues':
                    document.getElementById('dialoguesPane').style.display = 'flex';
                    break;
            }
            
            // ナビゲーションのアクティブ状態を更新
            document.querySelectorAll('.mobile-nav-item').forEach(item => {
                item.classList.remove('active');
            });
            event.target.closest('.mobile-nav-item').classList.add('active');
        }
        
        // ウィンドウリサイズ時の処理
        function handleResize() {
            if (window.innerWidth > 768) {
                // デスクトップ表示
                document.getElementById('mainPane').style.display = 'flex';
                document.getElementById('scenesPane').style.display = 'flex';
                document.getElementById('pagesPane').style.display = 'flex';
                document.getElementById('dialoguesPane').style.display = 'flex';
            } else {
                // モバイル表示
                switchTab(currentTab);
            }
        }
        
        // DOMContentLoadedで初期化
        document.addEventListener('DOMContentLoaded', () => {
            mainEditor = document.getElementById('mainEditor');
            scenesContent = document.getElementById('scenesContent');
            pagesContent = document.getElementById('pagesContent');
            dialoguesContent = document.getElementById('dialoguesContent');
            scenesContainer = document.getElementById('scenesContainer');
            pagesContainer = document.getElementById('pagesContainer');
            dialoguesContainer = document.getElementById('dialoguesContainer');
            
            // 初期履歴を追加
            addToHistory(mainEditor.value);
            
            // イベントリスナー設定
            mainEditor.addEventListener('input', (e) => {
                updateUI();
                addToHistory(mainEditor.value);
            });
            
            // キーボードショートカット
            document.addEventListener('keydown', (e) => {
                if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                    e.preventDefault();
                    undo();
                } else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                    e.preventDefault();
                    redo();
                }
            });
            
            // ウィンドウリサイズイベント
            window.addEventListener('resize', handleResize);
            
            // スクロール同期の設定
            setupScrollSync();
            
            // 初期表示
            handleResize();
            updateUI();
        });
        
        // スクロール同期の設定
        let isScrolling = false;
        
        function setupScrollSync() {
            [scenesContainer, pagesContainer, dialoguesContainer].forEach(container => {
                container.addEventListener('scroll', (e) => {
                    if (!isScrolling) {
                        isScrolling = true;
                        const scrollTop = e.target.scrollTop;
                        [scenesContainer, pagesContainer, dialoguesContainer].forEach(other => {
                            if (other !== e.target) {
                                other.scrollTop = scrollTop;
                            }
                        });
                        setTimeout(() => { isScrolling = false; }, 10);
                    }
                });
            });
        }
        
        // テキストのパース
        function parseText(text) {
            const newData = {
                scenes: [],
                pages: [],
                dialogues: [],
                elements: [] // 統合された要素リスト（高さ計算用）
            };
            
            let currentTop = 10; // 初期マージン
            const itemMargin = 10; // アイテム間のマージン
            
            // シーンの抽出
            const sceneRegex = /\{シーン:\s*([^}]*)\}/g;
            let sceneMatch;
            let sceneIndex = 0;
            let globalPageNumber = 1;
            
            while ((sceneMatch = sceneRegex.exec(text)) !== null) {
                const sceneContent = sceneMatch[1];
                const sceneId = `scene-${sceneIndex}`;
                
                // シーンの開始位置
                const sceneTop = currentTop;
                
                // シーンのみの内容（ページ記法を除外）して行数を計算
                const sceneOnlyLines = sceneContent.split('\n').filter(line => !line.match(/^\[ページ:/));
                const sceneHeight = Math.max(100, sceneOnlyLines.length * 24 + 70);
                
                const sceneData = {
                    id: sceneId,
                    content: sceneContent,
                    fullMatch: sceneMatch[0],
                    startIndex: sceneMatch.index,
                    endIndex: sceneMatch.index + sceneMatch[0].length,
                    top: sceneTop,
                    height: sceneHeight,
                    pages: []
                };
                
                // シーン内のページを抽出
                const pageRegex = /\[ページ:\s*([^\]]*)\]/g;
                let pageMatch;
                let pageTop = sceneTop; // 最初のページはシーンと同じ高さ
                let maxPageBottom = sceneTop; // ページの最下部を追跡
                
                while ((pageMatch = pageRegex.exec(sceneContent)) !== null) {
                    const pageContent = pageMatch[1];
                    const pageId = `page-${sceneIndex}-${sceneData.pages.length}`;
                    
                    // ページ内のセリフを抽出
                    const dialogues = [];
                    const dialogueRegex = /「([^」]*)」/g;
                    let dialogueMatch;
                    
                    while ((dialogueMatch = dialogueRegex.exec(pageContent)) !== null) {
                        dialogues.push(dialogueMatch[1]);
                    }
                    
                    // ページの高さを計算（改行を含む）
                    const pageLines = pageContent.split('\n').length;
                    const pageHeight = Math.max(80, pageLines * 24 + 70);
                    
                    // セリフの高さを計算（セリフ内の改行も考慮）
                    let totalDialogueLines = dialogues.length;
                    dialogues.forEach(d => {
                        totalDialogueLines += d.split('\n').length - 1;
                    });
                    const dialogueHeight = dialogues.length > 0 ? 
                        Math.max(80, 20 + totalDialogueLines * 40) : 80;
                    
                    // 2つ目以降のページは前のページの下に配置
                    if (sceneData.pages.length > 0) {
                        const lastPage = sceneData.pages[sceneData.pages.length - 1];
                        pageTop = lastPage.top + lastPage.pageHeight + itemMargin;
                    }
                    
                    const page = {
                        id: pageId,
                        content: pageContent,
                        sceneId: sceneId,
                        sceneIndex: sceneIndex,
                        dialogues: dialogues,
                        pageNumber: globalPageNumber++,
                        top: pageTop,
                        pageHeight: pageHeight,
                        dialogueHeight: dialogueHeight
                    };
                    
                    newData.pages.push(page);
                    sceneData.pages.push(page);
                    
                    // セリフをdialoguesに追加
                    newData.dialogues.push({
                        pageId: pageId,
                        sceneId: sceneId,
                        texts: dialogues,
                        top: pageTop,
                        height: dialogueHeight
                    });
                    
                    // 最下部を更新
                    maxPageBottom = pageTop + pageHeight;
                }
                
                // ページがない場合でも最小限の高さを確保
                if (sceneData.pages.length === 0) {
                    maxPageBottom = sceneTop + sceneHeight;
                }
                
                // ページ追加ボタンの位置を設定（ページタブの最下部に基づく）
                sceneData.addButtonTop = maxPageBottom + itemMargin;
                
                // 次の要素の開始位置を更新（シーンの高さではなく、ページの最下部に基づく）
                currentTop = sceneData.addButtonTop + 50 + itemMargin * 2;
                
                newData.scenes.push(sceneData);
                sceneIndex++;
            }
            
            // 全体の高さを設定
            newData.totalHeight = currentTop + 100;
            
            return newData;
        }
        
        // UIの更新
        function updateUI() {
            const text = mainEditor.value;
            data = parseText(text);
            
            // 各コンテナの高さを設定
            scenesContent.style.height = `${data.totalHeight}px`;
            pagesContent.style.height = `${data.totalHeight}px`;
            dialoguesContent.style.height = `${data.totalHeight}px`;
            
            // シーンの表示
            updateScenes();
            
            // ページの表示
            updatePages();
            
            // セリフの表示
            updateDialogues();
        }
        
        // シーンの更新
        function updateScenes() {
            scenesContent.innerHTML = '';
            
            data.scenes.forEach((scene, index) => {
                const sceneItem = document.createElement('div');
                sceneItem.className = 'sync-item scene-item';
                sceneItem.style.top = `${scene.top}px`;
                sceneItem.style.height = `${scene.height}px`;
                
                sceneItem.innerHTML = `
                    <div class="scene-header">
                        <span class="scene-label">シーン ${index + 1}</span>
                        <button class="delete-button" onclick="deleteScene(${index})">削除</button>
                    </div>
                    <div class="scene-content" contenteditable="true" data-index="${index}" data-type="scene">${textToHtml(scene.content)}</div>
                `;
                
                // 編集イベント
                const contentDiv = sceneItem.querySelector('.scene-content');
                let isComposing = false;
                
                contentDiv.addEventListener('compositionstart', () => {
                    isComposing = true;
                });
                
                contentDiv.addEventListener('compositionend', () => {
                    isComposing = false;
                });
                
                contentDiv.addEventListener('input', (e) => {
                    if (!isComposing) {
                        const newContent = htmlToText(e.target.innerHTML);
                        updateSceneContent(index, newContent, false);
                    }
                });
                
                contentDiv.addEventListener('blur', (e) => {
                    const newContent = htmlToText(e.target.innerHTML);
                    updateSceneContent(index, newContent, true);
                });
                
                // 改行処理
                contentDiv.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        document.execCommand('insertHTML', false, '\n');
                        
                        // 高さを即座に更新
                        setTimeout(() => {
                            const newHeight = Math.max(100, contentDiv.scrollHeight + 70);
                            sceneItem.style.height = `${newHeight}px`;
                        }, 0);
                    }
                });
                
                scenesContent.appendChild(sceneItem);
            });
        }
        
        // ページの更新
        function updatePages() {
            pagesContent.innerHTML = '';
            
            let currentSceneId = null;
            let sceneIndex = 0;
            
            data.pages.forEach((page, index) => {
                // 新しいシーンのページグループの場合
                if (page.sceneId !== currentSceneId) {
                    currentSceneId = page.sceneId;
                    sceneIndex = page.sceneIndex;
                }
                
                const pageItem = document.createElement('div');
                pageItem.className = 'sync-item page-item';
                pageItem.style.top = `${page.top}px`;
                pageItem.style.height = `${page.pageHeight}px`;
                
                pageItem.innerHTML = `
                    <div class="page-header">
                        <span class="page-label">ページ ${page.pageNumber}</span>
                        <button class="delete-button" onclick="deletePage(${index})">削除</button>
                    </div>
                    <div class="page-content" contenteditable="true" data-index="${index}" data-type="page">${textToHtml(page.content)}</div>
                `;
                
                // 編集イベント
                const contentDiv = pageItem.querySelector('.page-content');
                let isComposing = false;
                
                contentDiv.addEventListener('compositionstart', () => {
                    isComposing = true;
                });
                
                contentDiv.addEventListener('compositionend', () => {
                    isComposing = false;
                });
                
                contentDiv.addEventListener('input', (e) => {
                    if (!isComposing) {
                        const newContent = htmlToText(e.target.innerHTML);
                        updatePageContent(index, newContent, false);
                        
                        // ページの高さを動的に更新
                        const newHeight = Math.max(80, contentDiv.scrollHeight + 70);
                        pageItem.style.height = `${newHeight}px`;
                        
                        // ボタンの位置を更新
                        updateButtonPositions();
                    }
                });
                
                contentDiv.addEventListener('blur', (e) => {
                    const newContent = htmlToText(e.target.innerHTML);
                    updatePageContent(index, newContent, true);
                });
                
                // 改行処理
                contentDiv.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        document.execCommand('insertHTML', false, '\n');
                        
                        // 高さを即座に更新
                        setTimeout(() => {
                            const newHeight = Math.max(80, contentDiv.scrollHeight + 70);
                            pageItem.style.height = `${newHeight}px`;
                            updateButtonPositions();
                        }, 0);
                    }
                });
                
                pagesContent.appendChild(pageItem);
            });
            
            // 各シーンのページ追加ボタンを配置
            data.scenes.forEach((scene, index) => {
                const addButton = document.createElement('button');
                addButton.className = 'add-page-button';
                addButton.dataset.sceneId = scene.id;
                addButton.style.top = `${scene.addButtonTop}px`;
                addButton.textContent = '+ このシーンにページを追加';
                addButton.onclick = () => addPageToScene(scene.id, index);
                
                pagesContent.appendChild(addButton);
            });
        }
        
        // ボタン位置の更新
        function updateButtonPositions() {
            const pageItems = pagesContent.querySelectorAll('.page-item');
            const buttons = pagesContent.querySelectorAll('.add-page-button');
            
            // 各シーンごとにボタン位置を計算
            data.scenes.forEach((scene, sceneIndex) => {
                let maxBottom = scene.top;
                
                // このシーンに属するページの最下部を検索
                data.pages.forEach((page, pageIndex) => {
                    if (page.sceneId === scene.id) {
                        const pageElement = pageItems[pageIndex];
                        if (pageElement) {
                            const pageBottom = parseInt(pageElement.style.top) + parseInt(pageElement.style.height);
                            maxBottom = Math.max(maxBottom, pageBottom);
                        }
                    }
                });
                
                // ボタンの位置を更新
                buttons.forEach(button => {
                    if (button.dataset.sceneId === scene.id) {
                        button.style.top = `${maxBottom + 10}px`;
                    }
                });
            });
        }
        
        // セリフの更新
        function updateDialogues() {
            dialoguesContent.innerHTML = '';
            
            data.dialogues.forEach((dialogueGroup) => {
                const dialogueItem = document.createElement('div');
                dialogueItem.className = 'sync-item dialogue-item';
                dialogueItem.style.top = `${dialogueGroup.top}px`;
                dialogueItem.style.height = `${dialogueGroup.height}px`;
                
                dialogueItem.innerHTML = `
                    <div class="dialogue-content">
                        ${dialogueGroup.texts.length > 0 ? 
                            dialogueGroup.texts.map(text => `<div class="dialogue-text">${textToHtml(text)}</div>`).join('') :
                            '<div class="empty-dialogue">セリフがありません</div>'
                        }
                    </div>
                `;
                
                dialoguesContent.appendChild(dialogueItem);
            });
        }
        
        // ドラッグ&ドロップイベントハンドラー
        function handleDragStart(e) {
            draggedElement = e.currentTarget;
            draggedType = e.currentTarget.dataset.type;
            draggedIndex = parseInt(e.currentTarget.dataset.index);
            e.currentTarget.classList.add('dragging');
        }
        
        function handleDragEnd(e) {
            e.currentTarget.classList.remove('dragging');
        }
        
        function handleDragOver(e) {
            e.preventDefault();
            const draggingOver = e.currentTarget;
            
            if (draggingOver !== draggedElement && draggingOver.dataset.type === draggedType) {
                draggingOver.classList.add('drag-over');
            }
        }
        
        function handleDragLeave(e) {
            e.currentTarget.classList.remove('drag-over');
        }
        
        function handleDrop(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('drag-over');
            
            const droppedOn = e.currentTarget;
            const droppedIndex = parseInt(droppedOn.dataset.index);
            
            if (draggedType === droppedOn.dataset.type && draggedIndex !== droppedIndex) {
                if (draggedType === 'scene') {
                    reorderScenes(draggedIndex, droppedIndex);
                } else if (draggedType === 'page') {
                    reorderPages(draggedIndex, droppedIndex);
                }
            }
        }
        
        // シーンの並び替え
        function reorderScenes(fromIndex, toIndex) {
            const text = mainEditor.value;
            const scenes = [...text.matchAll(/\{シーン:\s*([^}]*)\}/g)];
            
            if (scenes[fromIndex] && scenes[toIndex]) {
                const sceneTexts = scenes.map(match => match[0]);
                const movedScene = sceneTexts.splice(fromIndex, 1)[0];
                sceneTexts.splice(toIndex, 0, movedScene);
                
                let newText = text;
                scenes.forEach((scene, index) => {
                    newText = newText.replace(scene[0], `###SCENE_${index}###`);
                });
                sceneTexts.forEach((sceneText, index) => {
                    newText = newText.replace(`###SCENE_${scenes.findIndex(s => s[0] === sceneText)}###`, sceneText);
                });
                
                mainEditor.value = newText;
                updateUI();
            }
        }
        
        // ページの並び替え
        function reorderPages(fromIndex, toIndex) {
            const pageData = data.pages[fromIndex];
            const targetPageData = data.pages[toIndex];
            
            if (pageData && targetPageData && pageData.sceneId === targetPageData.sceneId) {
                if (pageData.sceneId) {
                    const scene = data.scenes.find(s => s.id === pageData.sceneId);
                    const scenePages = data.pages.filter(p => p.sceneId === pageData.sceneId);
                    
                    const fromLocalIndex = scenePages.findIndex(p => p === pageData);
                    const toLocalIndex = scenePages.findIndex(p => p === targetPageData);
                    
                    reorderPagesInScene(scene, fromLocalIndex, toLocalIndex);
                }
            }
        }
        
        // シーン内でのページ並び替え
        function reorderPagesInScene(scene, fromIndex, toIndex) {
            const text = mainEditor.value;
            const sceneMatch = text.match(new RegExp(`\\{シーン:\\s*${escapeRegExp(scene.content)}\\}`));
            
            if (sceneMatch) {
                const sceneContent = sceneMatch[0];
                const pages = [...sceneContent.matchAll(/\[ページ:\s*([^\]]*)\]/g)];
                
                if (pages[fromIndex] && pages[toIndex]) {
                    const pageTexts = pages.map(match => match[0]);
                    const movedPage = pageTexts.splice(fromIndex, 1)[0];
                    pageTexts.splice(toIndex, 0, movedPage);
                    
                    let newSceneContent = sceneContent;
                    pages.forEach((page, index) => {
                        newSceneContent = newSceneContent.replace(page[0], `###PAGE_${index}###`);
                    });
                    pageTexts.forEach((pageText, index) => {
                        newSceneContent = newSceneContent.replace(`###PAGE_${pages.findIndex(p => p[0] === pageText)}###`, pageText);
                    });
                    
                    mainEditor.value = text.replace(sceneContent, newSceneContent);
                    updateUI();
                }
            }
        }
        
        // 正規表現のエスケープ
        function escapeRegExp(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }
        
        // シーン内容の更新
        function updateSceneContent(index, newContent, shouldUpdateUI = true) {
            const text = mainEditor.value;
            const scenes = [...text.matchAll(/\{シーン:\s*([^}]*)\}/g)];
            
            if (scenes[index]) {
                const oldScene = scenes[index][0];
                const oldContent = scenes[index][1];
                // 末尾の改行を保持
                const trimmedOldContent = oldContent.replace(/\n+$/, '');
                const trimmedNewContent = newContent.replace(/\n+$/, '');
                const trailingNewlines = oldContent.match(/\n*$/)[0];
                const newScene = oldScene.replace(oldContent, trimmedNewContent + trailingNewlines);
                
                const newText = text.replace(oldScene, newScene);
                mainEditor.value = newText;
                
                // メインタブの変更イベントを発火
                mainEditor.dispatchEvent(new Event('input', { bubbles: true }));
                
                if (shouldUpdateUI) {
                    updateUI();
                }
            }
        }
        
        // ページ内容の更新
        function updatePageContent(index, newContent, shouldUpdateUI = true) {
            const text = mainEditor.value;
            const allPages = [...text.matchAll(/\[ページ:\s*([^\]]*)\]/g)];
            
            let pageCount = 0;
            for (let match of allPages) {
                if (pageCount === index) {
                    const oldPage = match[0];
                    const oldContent = match[1];
                    // 末尾の改行を保持
                    const trimmedOldContent = oldContent.replace(/\n+$/, '');
                    const trimmedNewContent = newContent.replace(/\n+$/, '');
                    const trailingNewlines = oldContent.match(/\n*$/)[0];
                    const newPage = oldPage.replace(oldContent, trimmedNewContent + trailingNewlines);
                    
                    const newText = text.replace(oldPage, newPage);
                    mainEditor.value = newText;
                    
                    // メインタブの変更イベントを発火
                    mainEditor.dispatchEvent(new Event('input', { bubbles: true }));
                    
                    if (shouldUpdateUI) {
                        updateUI();
                    }
                    break;
                }
                pageCount++;
            }
        }
        
        // シーンの削除
        function deleteScene(index) {
            if (confirm('このシーンを削除しますか？')) {
                const text = mainEditor.value;
                const scenes = [...text.matchAll(/\{シーン:\s*([^}]*)\}/g)];
                
                if (scenes[index]) {
                    mainEditor.value = text.replace(scenes[index][0], '');
                    updateUI();
                }
            }
        }
        
        // ページの削除
        function deletePage(index) {
            if (confirm('このページを削除しますか？')) {
                const text = mainEditor.value;
                const allPages = [...text.matchAll(/\[ページ:\s*([^\]]*)\]/g)];
                
                let pageCount = 0;
                for (let match of allPages) {
                    if (pageCount === index) {
                        mainEditor.value = text.replace(match[0], '');
                        break;
                    }
                    pageCount++;
                }
                updateUI();
            }
        }
        
        // シーンの追加
        function addScene() {
            const newScene = '\n\n{シーン: 新しいシーン\n[ページ: 新しいページ\n「セリフ」\n]\n}';
            mainEditor.value += newScene;
            updateUI();
        }
        
        // ページの追加（新しいシーンを自動生成）
        function addPage() {
            const newScene = '\n\n{シーン: 新しいシーン\n[ページ: 新しいページ\n「セリフ」\n]\n}';
            mainEditor.value += newScene;
            updateUI();
        }
        
        // 特定のシーンにページを追加
        function addPageToScene(sceneId, sceneIndex) {
            const text = mainEditor.value;
            const scenes = [...text.matchAll(/\{シーン:\s*([^}]*)\}/g)];
            
            if (scenes[sceneIndex]) {
                const sceneMatch = scenes[sceneIndex];
                const sceneContent = sceneMatch[0];
                const newPage = '\n[ページ: 新しいページ\n「セリフ」\n]';
                const newSceneContent = sceneContent.replace(/\}$/, newPage + '\n}');
                
                mainEditor.value = text.replace(sceneContent, newSceneContent);
                updateUI();
            }
        }
        
        // セリフのエクスポート（1行開け）
        function exportDialogues() {
            const allDialogues = [];
            data.dialogues.forEach(group => {
                allDialogues.push(...group.texts);
            });
            
            // 各セリフの間に空行を入れる
            const dialogueText = allDialogues.join('\n\n');
            const blob = new Blob([dialogueText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'dialogues.txt';
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // ファイルの保存
        let currentFileName = null;
        
        function saveFile() {
            const text = mainEditor.value;
            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = currentFileName || 'tree-editor-document.txt';
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // 新規作成
        function newFile() {
            if (mainEditor.value && !confirm('現在の内容を破棄して新規作成しますか？')) {
                return;
            }
            mainEditor.value = '';
            currentFileName = null;
            history = [''];
            historyIndex = 0;
            updateUI();
        }
        
        // ファイルを開く
        function openFile() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.txt';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        mainEditor.value = e.target.result;
                        currentFileName = file.name;
                        history = [e.target.result];
                        historyIndex = 0;
                        updateUI();
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }
        
        // ファイルドロップ処理
        function handleFileDrop(e) {
            e.preventDefault();
            const file = e.dataTransfer.files[0];
            if (file && file.type === 'text/plain') {
                const reader = new FileReader();
                reader.onload = (e) => {
                    mainEditor.value = e.target.result;
                    currentFileName = file.name;
                    history = [e.target.result];
                    historyIndex = 0;
                    updateUI();
                };
                reader.readAsText(file);
            }
        }
        
        function handleDragOver(e) {
            e.preventDefault();
        }
        
        // HTMLエスケープ関数
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // テキストをHTMLに変換（改行を<br>に）
        function textToHtml(text) {
            return escapeHtml(text).replace(/\n/g, '<br>');
        }
        
        // HTMLをテキストに変換（<br>を改行に）
        function htmlToText(html) {
            // <br>タグを改行に変換
            let text = html.replace(/<br\s*\/?>/gi, '\n');
            // divタグを改行に変換（contenteditableでdivが生成される場合）
            text = text.replace(/<\/div><div>/gi, '\n');
            text = text.replace(/<div>/gi, '\n');
            text = text.replace(/<\/div>/gi, '');
            // その他のHTMLタグを削除
            text = text.replace(/<[^>]*>/g, '');
            // HTMLエンティティをデコード
            const textarea = document.createElement('textarea');
            textarea.innerHTML = text;
            // 先頭の改行を削除（divタグによる余分な改行）
            return textarea.value.replace(/^\n/, '');
        }
    </script>
</body>
</html>