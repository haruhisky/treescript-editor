<!DOCTYPE html>
<html lang="ja">
<head>
    <link rel="manifest" href="./manifest.json">
    <link rel="apple-touch-icon" href="./icon-192.png">
    <link rel="apple-touch-icon" sizes="180x180" href="./icon-180.png">
    <link rel="apple-touch-icon" sizes="152x152" href="./icon-152.png">
    <link rel="apple-touch-icon" sizes="120x120" href="./icon-120.png">
    <link rel="icon" type="image/png" sizes="32x32" href="./icon-32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="./icon-16.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TreeScript Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #f5f5f5;
            height: 100vh;
            overflow: hidden;
            touch-action: pan-y;
        }
        
        .app-container {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        .app-header {
            background: #2c3e50;
            color: white;
            padding: 12px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            z-index: 10;
        }
        
        .header-title {
            font-size: 18px;
            font-weight: bold;
        }
        
        .header-buttons {
            display: flex;
            gap: 8px;
        }
        
        .header-button {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .header-button:active {
            background: rgba(255,255,255,0.3);
        }
        
        .content-container {
            flex: 1;
            display: flex;
            overflow: hidden;
        }
        
        /* PC版のスワイパーラッパー */
        .swiper-wrapper {
            display: flex;
            width: 100%;
            height: 100%;
        }
        
        @media (min-width: 768px) {
            .swiper-wrapper {
                transform: none !important;
            }
        }
        
        .column {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: white;
            border-right: 1px solid #ddd;
            min-width: 250px;
            height: 100%;
        }
        
        .column:last-child {
            border-right: none;
        }
        
        .column-header {
            background: #34495e;
            color: white;
            padding: 12px 16px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }
        
        .column-button {
            background: #6c757d;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .column-button:hover {
            background: #5a6268;
        }
        
        .main-editor-container {
            flex: 1;
            padding: 16px;
            overflow-y: auto;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
        }
        
        .main-editor {
            width: 100%;
            min-height: calc(100% - 32px);
            border: none;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            line-height: 1.6;
            resize: none;
            background: transparent;
            outline: none;
        }
        
        .scenes-container {
            flex: 1;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            padding: 16px;
        }
        
        .scene-item {
            background: white;
            border-radius: 12px;
            margin-bottom: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            overflow: hidden;
            transition: all 0.3s ease;
        }
        
        .scene-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px;
            background: #e8f0fe;
            cursor: pointer;
            user-select: none;
        }
        
        .scene-header:hover {
            background: #dde7f5;
        }
        
        .scene-label {
            font-weight: bold;
            color: #1a73e8;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .scene-toggle {
            transition: transform 0.3s;
            font-size: 12px;
        }
        
        .scene-toggle.open {
            transform: rotate(90deg);
        }
        
        .scene-actions {
            display: flex;
            gap: 8px;
        }
        
        .scene-button {
            background: #6c757d;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
        }
        
        .scene-button.delete {
            background: #dc3545;
        }
        
        .scene-button.add-page {
            background: #17a2b8;
        }
        
        .scene-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }
        
        .scene-content.open {
            max-height: 2000px;
        }
        
        .scene-text {
            padding: 16px;
            background: #f8f9fa;
            min-height: 60px;
            white-space: pre-wrap;
            word-break: break-word;
            line-height: 1.6;
        }
        
        .scene-text:focus {
            outline: none;
            background: #f0f8ff;
        }
        
        .pages-container {
            padding: 0 16px 16px;
        }
        
        .page-item {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            margin-top: 8px;
            overflow: hidden;
        }
        
        .page-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: #f5f5f5;
        }
        
        .page-label {
            font-weight: 500;
            color: #5f6368;
        }
        
        .page-delete {
            background: #dc3545;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
        }
        
        .page-content {
            padding: 12px;
            min-height: 50px;
            white-space: pre-wrap;
            word-break: break-word;
            line-height: 1.6;
        }
        
        .page-content:focus {
            outline: none;
            background: #f0f8ff;
        }
        
        .dialogues-container {
            flex: 1;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            padding: 16px;
        }
        
        .dialogue-item {
            background: #fef7e0;
            border: 1px solid #f9ab00;
            border-radius: 8px;
            margin-bottom: 12px;
            padding: 12px;
        }
        
        .dialogue-header {
            font-weight: 500;
            color: #f9ab00;
            margin-bottom: 8px;
        }
        
        .dialogue-text {
            padding: 8px 12px;
            margin: 4px 0;
            background: white;
            border-radius: 8px;
            font-style: italic;
            cursor: text;
            transition: background 0.2s;
        }
        
        .dialogue-text:hover {
            background: #f8f8f8;
        }
        
        .dialogue-text:focus {
            outline: none;
            background: #f0f8ff;
            box-shadow: 0 0 0 2px #1a73e8;
        }
        
        .empty-state {
            text-align: center;
            padding: 40px;
            color: #999;
        }
        
        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 16px;
        }
        
        .undo-redo-buttons {
            display: flex;
            gap: 4px;
        }
        
        .undo-button, .redo-button {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 16px;
            cursor: pointer;
        }
        
        .undo-button:disabled, .redo-button:disabled {
            opacity: 0.5;
        }
        
        /* モバイル対応 */
        @media (max-width: 768px) {
            .app-header {
                display: flex;
            }
            
            .content-container {
                position: relative;
                overflow: hidden;
                flex: 1;
            }
            
            .swiper-wrapper {
                display: flex;
                height: 100%;
                transition: transform 0.3s ease-out;
                will-change: transform;
                width: 300%;
            }
            
            .column {
                width: 100%;
                height: 100%;
                flex-shrink: 0;
                border-right: none;
                min-width: auto;
                flex: none;
            }
            

            .column-header {
                display: flex; /* 非表示をflex表示に変更 */
                justify-content: space-between;
                align-items: center;
                padding: 8px; /* モバイル用の小さめパディング */
                background: #34495e; /* 背景色を維持 */
                color: white; /* 文字色を維持 */
            }

            .column-button {
                font-size: 10px; /* ボタンのサイズを小さめに調整 */
                padding: 4px 6px;
            }


            
            .scene-content.open {
                max-height: 1000px;
            }
            
            /* ページインジケーター */
            .page-indicators {
                position: absolute;
                bottom: 10px;
                left: 50%;
                transform: translateX(-50%);
                display: flex;
                gap: 8px;
                padding: 8px;
                background: rgba(0,0,0,0.3);
                border-radius: 20px;
                z-index: 5;
            }
            
            .indicator {
                width: 8px;
                height: 8px;
                border-radius: 50%;
                background: rgba(255,255,255,0.5);
                transition: background 0.3s;
            }
            
            .indicator.active {
                background: white;
            }
            
            /* タブバー */
            .tab-bar {
                display: flex;
                background: white;
                border-top: 1px solid #ddd;
                flex-shrink: 0;
                box-shadow: 0 -2px 4px rgba(0,0,0,0.05);
                z-index: 10;
            }
            
            .tab-item {
                flex: 1;
                padding: 12px;
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 4px;
                cursor: pointer;
                transition: background 0.2s;
                position: relative;
            }
            
            .tab-item:active {
                background: #f0f0f0;
            }
            
            .tab-item.active::before {
                content: '';
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                height: 3px;
                background: #1a73e8;
            }
            
            .tab-icon {
                font-size: 20px;
            }
            
            .tab-label {
                font-size: 11px;
                color: #666;
            }
            
            .tab-item.active .tab-label {
                color: #1a73e8;
            }
            
            .desktop-buttons {
                display: none !important;
            }
        }
        
        /* タブレット対応 */
        @media (min-width: 769px) and (max-width: 1024px) {
            .column {
                min-width: 200px;
            }
        }
        
        /* デスクトップでのレイアウト調整 */
        @media (min-width: 768px) {
            .app-header {
                display: none;
            }
            
            .page-indicators {
                display: none !important;
            }
            
            .tab-bar {
                display: none !important;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="app-header">
            <div class="header-title">TreeScript Editor</div>
            <div class="header-buttons">
                <div class="undo-redo-buttons">
                    <button id="undoButton" class="undo-button" onclick="undo()">↶</button>
                    <button id="redoButton" class="redo-button" onclick="redo()">↷</button>
                </div>
                <button class="header-button" onclick="showFileMenu()">📁</button>
            </div>
        </div>
        
        <div class="content-container" id="contentContainer">
            <div class="swiper-wrapper" id="swiperWrapper">
                <!-- 左カラム: メインエディタ -->
                <div class="column" data-page="0">
                    <div class="column-header">
                        <span>メインエディタ</span>
                        <div class="desktop-buttons">
                            <button class="column-button" onclick="newFile()">新規</button>
                            <button class="column-button" onclick="openFile()">開く</button>
                            <button class="column-button" onclick="saveFile()">保存</button>
                        </div>
                    </div>
                    <div class="main-editor-container">
                        <textarea id="mainEditor" class="main-editor" placeholder="ここにテキストを入力...

例:
{シーン: 朝の教室
生徒たちが登校してくる時間。
[ページ: 1ページ目
「おはよう！」
主人公が教室に入ってくる。
]
[ページ: 2ページ目
「今日も一日頑張ろう」
授業が始まる。
]
}

{シーン: 昼休み
[ページ: お弁当タイム
「お腹すいた～」
みんなでお弁当を食べる。
]
}"></textarea>
                    </div>
                </div>
                
                <!-- 中央カラム: シーン＆ページ -->
                <div class="column" data-page="1">
                    <div class="column-header">
                        <span>シーン＆ページ</span>
                        <button class="column-button" onclick="addScene()">+ シーン追加</button>
                    </div>
                    <div class="scenes-container" id="scenesContainer"></div>
                </div>
                
                <!-- 右カラム: セリフ -->
                <div class="column" data-page="2">
                    <div class="column-header">
                        <span>セリフ</span>
                        <button class="column-button" onclick="exportDialogues()">エクスポート</button>
                    </div>
                    <div class="dialogues-container" id="dialoguesContainer"></div>
                </div>
            </div>
            
            <!-- ページインジケーター（モバイル用） -->
            <div class="page-indicators" id="pageIndicators" style="display: none;">
                <span class="indicator active"></span>
                <span class="indicator"></span>
                <span class="indicator"></span>
            </div>
        </div>
        
        <!-- タブバー（モバイル用） -->
        <div class="tab-bar" id="tabBar" style="display: none;">
            <div class="tab-item active" data-page="0" onclick="switchToPage(0)">
                <span class="tab-icon">📝</span>
                <span class="tab-label">メイン</span>
            </div>
            <div class="tab-item" data-page="1" onclick="switchToPage(1)">
                <span class="tab-icon">🎬</span>
                <span class="tab-label">シーン</span>
            </div>
            <div class="tab-item" data-page="2" onclick="switchToPage(2)">
                <span class="tab-icon">💬</span>
                <span class="tab-label">セリフ</span>
            </div>
        </div>
    </div>

    <script>
        // グローバル変数
        let currentPage = 0;
        let data = {
            scenes: [],
            pages: [],
            dialogues: []
        };
        
        // DOM要素
        let mainEditor;
        let scenesContainer;
        let dialoguesContainer;
        let undoButton;
        let redoButton;
        let swiperWrapper;
        let pageIndicators;
        let tabBar;
        
        // 履歴管理
        let history = [];
        let historyIndex = -1;
        const maxHistory = 50;
        let isUpdatingFromHistory = false;
        
        // 現在開いているシーン
        let currentOpenScene = null;
        
        // スワイプ制御
        let touchStartX = 0;
        let touchEndX = 0;
        let isSwiping = false;
        
        // ローカルストレージのキー
        const STORAGE_KEY = 'treescript_data';
        const STORAGE_HISTORY_KEY = 'treescript_history';
        const STORAGE_HISTORY_INDEX_KEY = 'treescript_history_index';
        
        // 初期化
        document.addEventListener('DOMContentLoaded', () => {
            // DOM要素の取得
            mainEditor = document.getElementById('mainEditor');
            scenesContainer = document.getElementById('scenesContainer');
            dialoguesContainer = document.getElementById('dialoguesContainer');
            undoButton = document.getElementById('undoButton');
            redoButton = document.getElementById('redoButton');
            swiperWrapper = document.getElementById('swiperWrapper');
            pageIndicators = document.getElementById('pageIndicators');
            tabBar = document.getElementById('tabBar');
            
            // モバイル対応の初期化
            updateMobileLayout();
            window.addEventListener('resize', updateMobileLayout);
            
            // データの復元
            loadFromStorage();
            
            // イベントリスナーの設定
            setupEventListeners();
            
            // 初期表示
            updateUI();
        });
        
        // モバイルレイアウトの更新
        let swipeEventsAdded = false;

        function updateMobileLayout() {
            const isMobile = window.innerWidth < 768;

            if (isMobile) {
                pageIndicators.style.display = 'flex';
                tabBar.style.display = 'flex';
                swiperWrapper.style.display = 'flex';
                swiperWrapper.style.transform = `translateX(-${currentPage * 100}%)`;
                document.querySelector('.app-header').style.display = 'flex';

                document.querySelectorAll('.desktop-buttons').forEach(btn => {
                    btn.style.display = 'none';
                });

                if (!swipeEventsAdded) {
                    swiperWrapper.addEventListener('touchstart', handleTouchStart, { passive: true });
                    swiperWrapper.addEventListener('touchmove', handleTouchMove, { passive: true });
                    swiperWrapper.addEventListener('touchend', handleTouchEnd);
                    swipeEventsAdded = true;
                }

            } else {
                pageIndicators.style.display = 'none';
                tabBar.style.display = 'none';
                swiperWrapper.style.display = 'flex';
                swiperWrapper.style.transform = 'none';
                document.querySelector('.app-header').style.display = 'none';

                document.querySelectorAll('.desktop-buttons').forEach(btn => {
                    btn.style.display = 'flex';
                });

                if (swipeEventsAdded) {
                    swiperWrapper.removeEventListener('touchstart', handleTouchStart);
                    swiperWrapper.removeEventListener('touchmove', handleTouchMove);
                    swiperWrapper.removeEventListener('touchend', handleTouchEnd);
                    swipeEventsAdded = false;
                }
            }
        }

        
        // ローカルストレージからデータを読み込み
        function loadFromStorage() {
            try {
                const savedData = localStorage.getItem(STORAGE_KEY);
                const savedHistory = localStorage.getItem(STORAGE_HISTORY_KEY);
                const savedHistoryIndex = localStorage.getItem(STORAGE_HISTORY_INDEX_KEY);
                
                if (savedData) {
                    mainEditor.value = savedData;
                }
                
                if (savedHistory) {
                    history = JSON.parse(savedHistory);
                    historyIndex = savedHistoryIndex ? parseInt(savedHistoryIndex) : history.length - 1;
                } else {
                    history = [mainEditor.value];
                    historyIndex = 0;
                }
                
                updateUndoRedoButtons();
            } catch (e) {
                console.error('Failed to load from storage:', e);
                history = [mainEditor.value];
                historyIndex = 0;
            }
        }
        
        // ローカルストレージにデータを保存
        function saveToStorage() {
            try {
                localStorage.setItem(STORAGE_KEY, mainEditor.value);
                localStorage.setItem(STORAGE_HISTORY_KEY, JSON.stringify(history));
                localStorage.setItem(STORAGE_HISTORY_INDEX_KEY, historyIndex.toString());
            } catch (e) {
                console.error('Failed to save to storage:', e);
            }
        }
        
        // イベントリスナーの設定
        function setupEventListeners() {
            // テキストエディタのイベント
            let inputTimer = null;
            mainEditor.addEventListener('input', (e) => {
                updateUI();
                clearTimeout(inputTimer);
                inputTimer = setTimeout(() => {
                    addToHistory({
                        type: 'text',
                        content: mainEditor.value
                    });
                }, 500);
            });
            
            // スワイプイベント（モバイルのみ）
            if (window.innerWidth < 768) {
                swiperWrapper.addEventListener('touchstart', handleTouchStart, { passive: true });
                swiperWrapper.addEventListener('touchmove', handleTouchMove, { passive: true });
                swiperWrapper.addEventListener('touchend', handleTouchEnd);
            }
            
            // キーボードショートカット
            document.addEventListener('keydown', (e) => {
                if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                    e.preventDefault();
                    undo();
                } else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                    e.preventDefault();
                    redo();
                }
            });
        }
        
        // スワイプハンドラー
        function handleTouchStart(e) {
            touchStartX = e.touches[0].clientX;
            isSwiping = false;
        }
        
        function handleTouchMove(e) {
            if (!touchStartX) return;
            
            const touchX = e.touches[0].clientX;
            const diffX = touchX - touchStartX;
            
            if (Math.abs(diffX) > 10) {
                isSwiping = true;
            }
        }
        
        function handleTouchEnd(e) {
            if (!isSwiping) return;
            
            touchEndX = e.changedTouches[0].clientX;
            const diffX = touchEndX - touchStartX;
            
            // スワイプの判定（50px以上で切り替え）
            if (Math.abs(diffX) > 50) {
                if (diffX > 0 && currentPage > 0) {
                    // 右スワイプ（前のページへ）
                    switchToPage(currentPage - 1);
                } else if (diffX < 0 && currentPage < 2) {
                    // 左スワイプ（次のページへ）
                    switchToPage(currentPage + 1);
                }
            }
            
            touchStartX = 0;
            touchEndX = 0;
            isSwiping = false;
        }
        
        // ページ切り替え
        function switchToPage(pageIndex) {
            currentPage = pageIndex;
            const isMobile = window.innerWidth < 768;

            if (isMobile) {
                const offset = pageIndex * 100;
                swiperWrapper.style.transform = `translateX(-${offset}%)`;
            }

            updatePageIndicators();
            updateTabBar();
        }


        
        // ページインジケーターの更新
        function updatePageIndicators() {
            const indicators = pageIndicators.querySelectorAll('.indicator');
            indicators.forEach((indicator, index) => {
                indicator.classList.toggle('active', index === currentPage);
            });
        }
        
        // タブバーの更新
        function updateTabBar() {
            const tabs = tabBar.querySelectorAll('.tab-item');
            tabs.forEach((tab, index) => {
                tab.classList.toggle('active', index === currentPage);
            });
        }
        
        // ファイルメニューの表示
        function showFileMenu() {
            const menu = `
1. 新規作成
2. ファイルを開く
3. 保存
4. セリフをエクスポート

選択してください:`;
            
            const choice = prompt(menu);
            
            switch (choice) {
                case '1':
                    newFile();
                    break;
                case '2':
                    openFile();
                    break;
                case '3':
                    saveFile();
                    break;
                case '4':
                    exportDialogues();
                    break;
            }
        }
        
        // 履歴管理
        function addToHistory(action) {
            if (isUpdatingFromHistory) return;
            
            history = history.slice(0, historyIndex + 1);
            history.push(action);
            
            if (history.length > maxHistory) {
                history.shift();
            }
            
            historyIndex = history.length - 1;
            updateUndoRedoButtons();
            saveToStorage();
        }
        
        function updateUndoRedoButtons() {
            undoButton.disabled = historyIndex <= 0;
            redoButton.disabled = historyIndex >= history.length - 1;
        }
        
        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                isUpdatingFromHistory = true;
                applyHistoryAction(history[historyIndex]);
                isUpdatingFromHistory = false;
                updateUndoRedoButtons();
                saveToStorage();
            }
        }
        
        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                isUpdatingFromHistory = true;
                applyHistoryAction(history[historyIndex]);
                isUpdatingFromHistory = false;
                updateUndoRedoButtons();
                saveToStorage();
            }
        }
        
        function applyHistoryAction(action) {
            if (typeof action === 'string') {
                // 旧形式の履歴（文字列のみ）との互換性
                mainEditor.value = action;
            } else if (action.type === 'text') {
                mainEditor.value = action.content;
            }
            updateUI();
        }
        
        // テキストのパース
        function parseText(text) {
            const newData = {
                scenes: [],
                pages: [],
                dialogues: []
            };
            
            const sceneRegex = /\{シーン:\s*([^}]*)\}/g;
            let sceneMatch;
            let sceneIndex = 0;
            let globalPageNumber = 1;
            
            while ((sceneMatch = sceneRegex.exec(text)) !== null) {
                const sceneContent = sceneMatch[1];
                const sceneId = `scene-${sceneIndex}`;
                
                const sceneData = {
                    id: sceneId,
                    content: sceneContent,
                    fullMatch: sceneMatch[0],
                    startIndex: sceneMatch.index,
                    endIndex: sceneMatch.index + sceneMatch[0].length,
                    pages: []
                };
                
                const pageRegex = /\[ページ:\s*([^\]]*)\]/g;
                let pageMatch;
                
                while ((pageMatch = pageRegex.exec(sceneContent)) !== null) {
                    const pageContent = pageMatch[1];
                    const pageId = `page-${sceneIndex}-${sceneData.pages.length}`;
                    
                    const dialogues = [];
                    const dialogueRegex = /「([^」]*)」/g;
                    let dialogueMatch;
                    
                    while ((dialogueMatch = dialogueRegex.exec(pageContent)) !== null) {
                        dialogues.push(dialogueMatch[1]);
                    }
                    
                    const page = {
                        id: pageId,
                        content: pageContent,
                        sceneId: sceneId,
                        sceneIndex: sceneIndex,
                        dialogues: dialogues,
                        pageNumber: globalPageNumber++
                    };
                    
                    newData.pages.push(page);
                    sceneData.pages.push(page);
                    
                    newData.dialogues.push({
                        pageId: pageId,
                        sceneId: sceneId,
                        texts: dialogues,
                        pageNumber: page.pageNumber
                    });
                }
                
                newData.scenes.push(sceneData);
                sceneIndex++;
            }
            
            return newData;
        }
        
        // UI更新
        function updateUI() {
            // 現在開いているシーンのIDを保存
            const openScenes = [];
            document.querySelectorAll('.scene-content.open').forEach(content => {
                const sceneItem = content.closest('.scene-item');
                if (sceneItem && sceneItem.dataset.sceneId) {
                    openScenes.push(sceneItem.dataset.sceneId);
                }
            });
            
            const text = mainEditor.value;
            data = parseText(text);
            
            updateScenes();
            updateDialogues();
            saveToStorage();
            
            // 開いていたシーンを復元
            openScenes.forEach(sceneId => {
                const sceneItem = document.querySelector(`[data-scene-id="${sceneId}"]`);
                if (sceneItem) {
                    const sceneContent = sceneItem.querySelector('.scene-content');
                    const toggle = sceneItem.querySelector('.scene-toggle');
                    if (sceneContent && toggle) {
                        sceneContent.classList.add('open');
                        toggle.classList.add('open');
                    }
                }
            });
        }
        
        // シーンの更新
        function updateScenes() {
            // 現在開いているシーンのIDを取得
            const openScenes = [];
            document.querySelectorAll('.scene-content.open').forEach(content => {
                const sceneItem = content.closest('.scene-item');
                if (sceneItem && sceneItem.dataset.sceneId) {
                    openScenes.push(sceneItem.dataset.sceneId);
                }
            });
            
            scenesContainer.innerHTML = '';
            
            if (data.scenes.length === 0) {
                scenesContainer.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">🎬</div>
                        <div>シーンがありません</div>
                        <div style="font-size: 14px; margin-top: 8px;">「+ シーン追加」ボタンで追加してください</div>
                    </div>
                `;
                return;
            }
            
            data.scenes.forEach((scene, index) => {
                const sceneItem = document.createElement('div');
                sceneItem.className = 'scene-item';
                sceneItem.dataset.sceneId = scene.id;
                
                const isOpen = openScenes.includes(scene.id);  // ← ここが変更点
                
                sceneItem.innerHTML = `
                    <div class="scene-header" onclick="toggleScene('${scene.id}')">
                        <span class="scene-label">
                            <span class="scene-toggle ${isOpen ? 'open' : ''}">▶</span>
                            シーン ${index + 1}
                        </span>
                        <div class="scene-actions">
                            <button class="scene-button add-page" onclick="event.stopPropagation(); addPageToScene('${scene.id}', ${index})">+ ページ</button>
                            <button class="scene-button delete" onclick="event.stopPropagation(); deleteScene(${index})">削除</button>
                        </div>
                    </div>
                    <div class="scene-content ${isOpen ? 'open' : ''}">
                        <div class="scene-text" contenteditable="true" data-index="${index}" data-type="scene">${escapeHtml(getSceneDescription(scene.content)).replace(/\n/g, '<br>')}</div>
                        <div class="pages-container" id="pages-${scene.id}"></div>
                    </div>
                `;
                
                scenesContainer.appendChild(sceneItem);
                
                // シーンテキストの編集イベント
                const sceneText = sceneItem.querySelector('.scene-text');
                setupContentEditable(sceneText, index, 'scene');
                
                // ページの表示
                const pagesContainer = sceneItem.querySelector(`#pages-${scene.id}`);
                updatePagesInScene(pagesContainer, scene.pages);
            });
        }
        
        // シーンの説明部分のみを取得
        function getSceneDescription(content) {
            const pageRegex = /\[ページ:[\s\S]*?\]/g;
            return content.replace(pageRegex, '').trim();
        }
        
        // シーン内のページを更新
        function updatePagesInScene(container, pages) {
            container.innerHTML = '';
            
            pages.forEach((page, index) => {
                const pageItem = document.createElement('div');
                pageItem.className = 'page-item';
                
                pageItem.innerHTML = `
                    <div class="page-header">
                        <span class="page-label">ページ ${page.pageNumber}</span>
                        <button class="page-delete" onclick="deletePage(${data.pages.indexOf(page)})">削除</button>
                    </div>
                    <div class="page-content" contenteditable="true" data-index="${data.pages.indexOf(page)}" data-type="page">${escapeHtml(page.content).replace(/\n/g, '<br>')}</div>
                `;
                
                container.appendChild(pageItem);
                
                // ページ編集イベント
                const pageContent = pageItem.querySelector('.page-content');
                setupContentEditable(pageContent, data.pages.indexOf(page), 'page');
            });
        }
        

        // シーンの開閉切り替え
        function toggleScene(sceneId) {
            const sceneItem = document.querySelector(`[data-scene-id="${sceneId}"]`);
            const sceneContent = sceneItem.querySelector('.scene-content');
            const toggle = sceneItem.querySelector('.scene-toggle');
            
            // 開閉状態を切り替える
            if (sceneContent.classList.contains('open')) {
                // 閉じる
                sceneContent.classList.remove('open');
                toggle.classList.remove('open');
            } else {
                // 開く
                sceneContent.classList.add('open');
                toggle.classList.add('open');
            }
        }
        
        // セリフの更新
        function updateDialogues() {
            dialoguesContainer.innerHTML = '';
            
            if (data.dialogues.length === 0 || data.dialogues.every(d => d.texts.length === 0)) {
                dialoguesContainer.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">💬</div>
                        <div>セリフがありません</div>
                        <div style="font-size: 14px; margin-top: 8px;">ページに「」でセリフを追加してください</div>
                    </div>
                `;
                return;
            }
            
            data.dialogues.forEach((dialogueGroup, groupIndex) => {
                if (dialogueGroup.texts.length === 0) return;
                
                const dialogueItem = document.createElement('div');
                dialogueItem.className = 'dialogue-item';
                
                const dialogueTexts = dialogueGroup.texts.map((text, textIndex) => 
                    `<div class="dialogue-text" contenteditable="true" data-group="${groupIndex}" data-text="${textIndex}">${escapeHtml(text).replace(/\n/g, '<br>')}</div>`
                ).join('');
                
                dialogueItem.innerHTML = `
                    <div class="dialogue-header">ページ ${dialogueGroup.pageNumber}</div>
                    ${dialogueTexts}
                `;
                
                dialoguesContainer.appendChild(dialogueItem);
                
                // 各セリフテキストに編集イベントを設定
                dialogueItem.querySelectorAll('.dialogue-text').forEach((textElement) => {
                    setupDialogueEditable(textElement);
                });
            });
        }
        
        // コンテンツ編集可能要素のセットアップ
        function setupContentEditable(element, index, type) {
            let isComposing = false;
            
            element.addEventListener('compositionstart', () => {
                isComposing = true;
            });
            
            element.addEventListener('compositionend', () => {
                isComposing = false;
            });
            
            element.addEventListener('input', (e) => {
                if (!isComposing) {
                    const newContent = htmlToText(e.target.innerHTML);
                    if (type === 'scene') {
                        updateSceneContent(index, newContent, false);
                    } else if (type === 'page') {
                        updatePageContent(index, newContent, false);
                    }
                }
            });
            
            element.addEventListener('blur', (e) => {
                const newContent = htmlToText(e.target.innerHTML);
                if (type === 'scene') {
                    updateSceneContent(index, newContent, true);
                } else if (type === 'page') {
                    updatePageContent(index, newContent, true);
                }
                addToHistory({
                    type: 'text',
                    content: mainEditor.value
                });
            });
            
            element.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    document.execCommand('insertLineBreak');
                }
            });
        }
        
        // シーン内容の更新
        function updateSceneContent(index, newContent, shouldUpdateUI = true) {
            const text = mainEditor.value;
            const scenes = [...text.matchAll(/\{シーン:\s*([^}]*)\}/g)];
            
            if (scenes[index]) {
                const oldScene = scenes[index][0];
                const oldContent = scenes[index][1];
                
                // ページ部分を保持
                const pageMatches = [...oldContent.matchAll(/\[ページ:[\s\S]*?\]/g)];
                const pagesText = pageMatches.map(m => m[0]).join('\n');
                
                // 新しいシーン内容を構築
                const newSceneContent = newContent + (pagesText ? '\n' + pagesText : '');
                const newScene = `{シーン: ${newSceneContent}}`;
                
                mainEditor.value = text.replace(oldScene, newScene);
                if (shouldUpdateUI) {
                    updateUI();
                }
            }
        }
        
        // ページ内容の更新
        function updatePageContent(index, newContent, shouldUpdateUI = true) {
            const text = mainEditor.value;
            const allPages = [...text.matchAll(/\[ページ:\s*([^\]]*)\]/g)];
            
            let pageCount = 0;
            for (let match of allPages) {
                if (pageCount === index) {
                    const oldPage = match[0];
                    const newPage = `[ページ: ${newContent}]`;
                    
                    mainEditor.value = text.replace(oldPage, newPage);
                    if (shouldUpdateUI) {
                        updateUI();
                    }
                    break;
                }
                pageCount++;
            }
        }
        
        // シーンの削除
        function deleteScene(index) {
            if (confirm('このシーンを削除しますか？')) {
                const text = mainEditor.value;
                const scenes = [...text.matchAll(/\{シーン:\s*([^}]*)\}/g)];
                
                if (scenes[index]) {
                    mainEditor.value = text.replace(scenes[index][0], '');
                    updateUI();
                    addToHistory({
                        type: 'text',
                        content: mainEditor.value
                    });
                }
            }
        }
        
        // ページの削除
        function deletePage(index) {
            if (confirm('このページを削除しますか？')) {
                const text = mainEditor.value;
                const allPages = [...text.matchAll(/\[ページ:\s*([^\]]*)\]/g)];
                
                let pageCount = 0;
                for (let match of allPages) {
                    if (pageCount === index) {
                        mainEditor.value = text.replace(match[0], '');
                        break;
                    }
                    pageCount++;
                }
                updateUI();
                addToHistory({
                    type: 'text',
                    content: mainEditor.value
                });
            }
        }
        
        // シーンの追加
        function addScene() {
            const newScene = '\n\n{シーン: 新しいシーン\n[ページ: 新しいページ\n「セリフ」\n]\n}';
            mainEditor.value += newScene;
            updateUI();
            addToHistory({
                type: 'text',
                content: mainEditor.value
            });
        }
        
        // 特定のシーンにページを追加
        function addPageToScene(sceneId, sceneIndex) {
            const text = mainEditor.value;
            const scenes = [...text.matchAll(/\{シーン:\s*([^}]*)\}/g)];
            
            if (scenes[sceneIndex]) {
                const sceneMatch = scenes[sceneIndex];
                const sceneContent = sceneMatch[0];
                const newPage = '\n[ページ: 新しいページ\n「セリフ」\n]';
                const newSceneContent = sceneContent.replace(/\}$/, newPage + '\n}');
                
                mainEditor.value = text.replace(sceneContent, newSceneContent);
                updateUI();
                addToHistory({
                    type: 'text',
                    content: mainEditor.value
                });
            }
        }
        
        // セリフのエクスポート
        function exportDialogues() {
            const allDialogues = [];
            data.dialogues.forEach(group => {
                if (group.texts.length > 0) {
                    // ページ番号をコメントとして追加（必要に応じて）
                    // allDialogues.push(`--- ページ ${group.pageNumber} ---`);
                    
                    // 各セリフを一行空けで追加
                    group.texts.forEach((text, index) => {
                        allDialogues.push(text);
                        // 最後のセリフ以外は空行を追加
                        if (index < group.texts.length - 1) {
                            allDialogues.push('');
                        }
                    });
                    
                    // グループ間にも空行を追加
                    allDialogues.push('');
                }
            });
            
            // 最後の余分な空行を削除
            if (allDialogues[allDialogues.length - 1] === '') {
                allDialogues.pop();
            }
            
            const dialogueText = allDialogues.join('\n');
            const blob = new Blob([dialogueText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'dialogues.txt';
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // セリフ編集可能要素のセットアップ
        function setupDialogueEditable(element) {
            let isComposing = false;
            
            element.addEventListener('compositionstart', () => {
                isComposing = true;
            });
            
            element.addEventListener('compositionend', () => {
                isComposing = false;
            });
            
            element.addEventListener('input', (e) => {
                if (!isComposing) {
                    const groupIndex = parseInt(e.target.dataset.group);
                    const textIndex = parseInt(e.target.dataset.text);
                    const newContent = htmlToText(e.target.innerHTML);
                    updateDialogueContent(groupIndex, textIndex, newContent, false);
                }
            });
            
            element.addEventListener('blur', (e) => {
                const groupIndex = parseInt(e.target.dataset.group);
                const textIndex = parseInt(e.target.dataset.text);
                const newContent = htmlToText(e.target.innerHTML);
                updateDialogueContent(groupIndex, textIndex, newContent, true);
                addToHistory({
                    type: 'text',
                    content: mainEditor.value
                });
            });
            
            element.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    document.execCommand('insertLineBreak');
                }
            });
        }
        
        // セリフ内容の更新
        function updateDialogueContent(groupIndex, textIndex, newContent, shouldUpdateUI = true) {
            const dialogueGroup = data.dialogues[groupIndex];
            if (!dialogueGroup) return;
            
            const pageData = data.pages.find(p => p.id === dialogueGroup.pageId);
            if (!pageData) return;
            
            // メインエディタのテキストを更新
            const text = mainEditor.value;
            const oldDialogue = `「${dialogueGroup.texts[textIndex]}」`;
            const newDialogue = `「${newContent}」`;
            
            // すべてのセリフを検索し、正しいものを更新
            let dialogueCount = 0;
            let targetDialogueIndex = 0;
            
            // 対象のセリフが全体で何番目かを計算
            for (let i = 0; i < groupIndex; i++) {
                targetDialogueIndex += data.dialogues[i].texts.length;
            }
            targetDialogueIndex += textIndex;
            
            // テキスト内のすべてのセリフを置換
            const updatedText = text.replace(/「([^」]*)」/g, (match, content) => {
                if (dialogueCount === targetDialogueIndex) {
                    dialogueCount++;
                    return newDialogue;
                }
                dialogueCount++;
                return match;
            });
            
            mainEditor.value = updatedText;
            if (shouldUpdateUI) {
                updateUI();
            }
        }
        
        // ファイル操作
        let currentFileName = null;
        
        function newFile() {
            if (mainEditor.value && !confirm('現在の内容を破棄して新規作成しますか？')) {
                return;
            }
            mainEditor.value = '';
            currentFileName = null;
            history = [''];
            historyIndex = 0;
            currentOpenScene = null;
            updateUI();
            updateUndoRedoButtons();
        }
        
        function openFile() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.txt';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        mainEditor.value = e.target.result;
                        currentFileName = file.name;
                        history = [{type: 'text', content: e.target.result}];
                        historyIndex = 0;
                        currentOpenScene = null;
                        updateUI();
                        updateUndoRedoButtons();
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }
        
        function saveFile() {
            const defaultName = currentFileName || 'treescript-document.txt';
            const fileName = prompt('ファイル名を入力してください:', defaultName);
            
            if (fileName) {
                const finalFileName = fileName.endsWith('.txt') ? fileName : fileName + '.txt';
                
                const text = mainEditor.value;
                const blob = new Blob([text], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = finalFileName;
                a.click();
                URL.revokeObjectURL(url);
                
                currentFileName = finalFileName;
            }
        }
        
        // ユーティリティ関数
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function htmlToText(html) {
            let text = html.replace(/<br\s*\/?>/gi, '\n');
            text = text.replace(/<[^>]*>/g, '');
            const textarea = document.createElement('textarea');
            textarea.innerHTML = text;
            return textarea.value;
        }
        
        // Service Worker登録
        try {
            if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => {
                    navigator.serviceWorker.register('./service-worker.js')
                        .then(reg => console.log('SW registered'))
                        .catch(err => console.log('SW registration failed:', err));
                });
            }
        } catch (error) {
            console.log('Service Worker is not available in this environment:', error);
        }
    </script>
</body>
</html>