<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ãƒ„ãƒªãƒ¼ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #f5f5f5;
            height: 100vh;
            overflow: hidden;
            margin: 0;
            padding: 0;
        }
        
        .container {
            display: flex;
            height: 100vh;
            gap: 1px;
            background: #ddd;
        }
        
        .editor-pane {
            flex: 1;
            background: white;
            display: flex;
            flex-direction: column;
            min-width: 0; /* flexã‚¢ã‚¤ãƒ†ãƒ ã®ç¸®å°ã‚’è¨±å¯ */
            position: relative;
        }
        
        .pane-header {
            background: #2c3e50;
            color: white;
            padding: 12px 16px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }
        
        .pane-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            position: relative;
        }
        
        /* ãƒ¡ã‚¤ãƒ³ã‚¿ãƒ–ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¨ãƒªã‚¢ */
        .editor-pane:first-child .pane-content {
            overflow: hidden;
        }
        
        /* åŒæœŸã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ç”¨ã®ã‚³ãƒ³ãƒ†ãƒŠ */
        .sync-scroll-pane {
            overflow-y: auto !important;
        }
        
        .sync-scroll-content {
            position: relative;
            padding-bottom: 50px;
        }
        
        .main-editor {
            width: 100%;
            height: 100%;
            border: none;
            padding: 16px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            line-height: 1.6;
            resize: none;
            overflow-y: auto;
        }
        
        /* å„è¦ç´ ã®é«˜ã•ã‚’çµ±ä¸€ã™ã‚‹ãŸã‚ã®åŸºæœ¬ã‚¹ã‚¿ã‚¤ãƒ« */
        .sync-item {
            position: absolute;
            left: 0;
            right: 0;
            padding: 8px;
        }
        
        /* ã‚·ãƒ¼ãƒ³è¦ç´ ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .scene-item {
            background: #e8f0fe;
            border: 1px solid #dadce0;
            border-radius: 8px;
            padding: 12px;
            margin: 0 8px;
            width: calc(100% - 16px);
        }
        
        .scene-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .scene-label {
            background: #1a73e8;
            color: white;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }
        
        .scene-content {
            background: white;
            border: 1px solid #dadce0;
            border-radius: 4px;
            padding: 8px;
            min-height: 60px;
            white-space: pre-wrap;
            word-break: break-word;
            font-size: 14px;
            line-height: 1.6;
        }
        
        .scene-content:focus {
            outline: none;
            border-color: #1a73e8;
            box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.2);
        }
        
        /* contenteditableç”¨ã®æ”¹è¡Œè¡¨ç¤ºè¨­å®š */
        .scene-content br,
        .page-content br {
            display: block;
            content: "";
        }
        
        .scene-content:empty:before,
        .page-content:empty:before {
            content: attr(placeholder);
            color: #999;
        }
        
        /* ãƒšãƒ¼ã‚¸è¦ç´ ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .page-item {
            background: #f8f9fa;
            border: 1px solid #dadce0;
            border-radius: 8px;
            padding: 12px;
            margin: 0 8px;
            width: calc(100% - 16px);
        }
        
        .page-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .page-label {
            background: #5f6368;
            color: white;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }
        
        .page-content {
            background: white;
            border: 1px solid #dadce0;
            border-radius: 4px;
            padding: 8px;
            min-height: 40px;
            white-space: pre-wrap;
            word-break: break-word;
            font-size: 14px;
            line-height: 1.6;
        }
        
        .page-content:focus {
            outline: none;
            border-color: #5f6368;
            box-shadow: 0 0 0 2px rgba(95, 99, 104, 0.2);
        }
        
        /* ã‚»ãƒªãƒ•è¦ç´ ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .dialogue-item {
            background: #fef7e0;
            border: 1px solid #f9ab00;
            border-radius: 8px;
            padding: 12px;
            margin: 0 8px;
            width: calc(100% - 16px);
        }
        
        .dialogue-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .dialogue-label {
            background: #f9ab00;
            color: #202124;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }
        
        .dialogue-content {
            background: white;
            border: 1px solid #f9ab00;
            border-radius: 4px;
            padding: 8px;
            color: #202124;
        }
        
        .dialogue-text {
            margin: 4px 0;
            padding: 4px 8px;
            background: #fffbf0;
            border-left: 3px solid #f9ab00;
            font-style: italic;
        }
        
        /* ãƒœã‚¿ãƒ³ã‚¹ã‚¿ã‚¤ãƒ« */
        .delete-button {
            background: #dc3545;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .delete-button:hover {
            background: #c82333;
        }
        
        .export-button {
            background: #6c757d;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .export-button:hover {
            background: #5a6268;
        }
        
        .add-button {
            background: #28a745;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .add-button:hover {
            background: #218838;
        }
        
        /* ãƒšãƒ¼ã‚¸è¿½åŠ ãƒœã‚¿ãƒ³ */
        .add-page-button {
            position: absolute;
            left: 8px;
            right: 8px;
            background: #17a2b8;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            text-align: center;
        }
        
        .add-page-button:hover {
            background: #138496;
        }
        
        /* ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .dragging {
            opacity: 0.5;
        }
        
        .drag-over {
            border-top: 3px solid #1a73e8;
        }
        
        /* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ */
        @media (max-width: 1200px) {
            .editor-pane {
                min-width: 200px;
            }
        }
        
        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            
            .editor-pane {
                min-width: unset;
                width: 100%;
            }
            
            /* ãƒ¢ãƒã‚¤ãƒ«ã§ã¯æœ€åˆã®ãƒšã‚¤ãƒ³ã®ã¿è¡¨ç¤º */
            .editor-pane:not(:first-child) {
                display: none;
            }
            
            .pane-header {
                position: sticky;
                top: 0;
                z-index: 100;
            }
            
            .main-editor {
                font-size: 16px; /* ãƒ¢ãƒã‚¤ãƒ«ã§ã®è‡ªå‹•ã‚ºãƒ¼ãƒ é˜²æ­¢ */
            }
            
            /* ãƒšãƒ¼ã‚¸è¿½åŠ ãƒœã‚¿ãƒ³ã‚’ãƒ¢ãƒã‚¤ãƒ«ã§è¦‹ã‚„ã™ã */
            .add-page-button {
                position: relative !important;
                margin: 10px 8px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- ãƒ¡ã‚¤ãƒ³ã‚¿ãƒ– -->
        <div class="editor-pane" id="mainPane">
            <div class="pane-header">
                <span>ãƒ¡ã‚¤ãƒ³ã‚¿ãƒ–</span>
                <div>
                    <button onclick="newFile()" class="export-button">æ–°è¦ä½œæˆ</button>
                    <button onclick="openFile()" class="export-button">é–‹ã</button>
                    <button onclick="saveFile()" class="export-button">ä¸Šæ›¸ãä¿å­˜</button>
                    <button onclick="undo()" class="export-button" title="å…ƒã«æˆ»ã™ (Ctrl+Z)">â†¶</button>
                    <button onclick="redo()" class="export-button" title="ã‚„ã‚Šç›´ã— (Ctrl+Y)">â†·</button>
                </div>
            </div>
            <div class="pane-content" ondrop="handleFileDrop(event)" ondragover="handleDragOver(event)">
                <textarea id="mainEditor" class="main-editor" placeholder="ã“ã“ã«ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›...

ä¾‹:
{ã‚·ãƒ¼ãƒ³: æœã®æ•™å®¤
ç”Ÿå¾’ãŸã¡ãŒç™»æ ¡ã—ã¦ãã‚‹æ™‚é–“ã€‚
[ãƒšãƒ¼ã‚¸: 1ãƒšãƒ¼ã‚¸ç›®
ã€ŒãŠã¯ã‚ˆã†ï¼ã€
ä¸»äººå…¬ãŒæ•™å®¤ã«å…¥ã£ã¦ãã‚‹ã€‚
]
[ãƒšãƒ¼ã‚¸: 2ãƒšãƒ¼ã‚¸ç›®
ã€Œä»Šæ—¥ã‚‚ä¸€æ—¥é ‘å¼µã‚ã†ã€
æˆæ¥­ãŒå§‹ã¾ã‚‹ã€‚
]
}

{ã‚·ãƒ¼ãƒ³: æ˜¼ä¼‘ã¿
[ãƒšãƒ¼ã‚¸: ãŠå¼å½“ã‚¿ã‚¤ãƒ 
ã€ŒãŠè…¹ã™ã„ãŸï½ã€
ã¿ã‚“ãªã§ãŠå¼å½“ã‚’é£Ÿã¹ã‚‹ã€‚
]
}"></textarea>
            </div>
        </div>
        
        <!-- ã‚·ãƒ¼ãƒ³ã‚¿ãƒ– -->
        <div class="editor-pane" id="scenesPane" style="display: none;">
            <div class="pane-header">
                <span>ã‚·ãƒ¼ãƒ³ã‚¿ãƒ–</span>
                <button onclick="addScene()" class="export-button">ã‚·ãƒ¼ãƒ³è¿½åŠ </button>
            </div>
            <div class="pane-content sync-scroll-pane" id="scenesContainer">
                <div class="sync-scroll-content" id="scenesContent"></div>
            </div>
        </div>
        
        <!-- ãƒšãƒ¼ã‚¸ã‚¿ãƒ– -->
        <div class="editor-pane" id="pagesPane" style="display: none;">
            <div class="pane-header">
                <span>ãƒšãƒ¼ã‚¸ã‚¿ãƒ–</span>
                <button onclick="addPage()" class="export-button">ãƒšãƒ¼ã‚¸è¿½åŠ </button>
            </div>
            <div class="pane-content sync-scroll-pane" id="pagesContainer">
                <div class="sync-scroll-content" id="pagesContent"></div>
            </div>
        </div>
        
        <!-- ã‚»ãƒªãƒ•ã‚¿ãƒ– -->
        <div class="editor-pane" id="dialoguesPane" style="display: none;">
            <div class="pane-header">
                <span>ã‚»ãƒªãƒ•ã‚¿ãƒ–</span>
                <button onclick="exportDialogues()" class="export-button">ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button>
            </div>
            <div class="pane-content sync-scroll-pane" id="dialoguesContainer">
                <div class="sync-scroll-content" id="dialoguesContent"></div>
            </div>
        </div>
    </div>
    
    <!-- ãƒ¢ãƒã‚¤ãƒ«ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ -->
    <nav class="mobile-nav">
        <div class="mobile-nav-items">
            <div class="mobile-nav-item active" onclick="switchTab('main')">
                <div>ğŸ“</div>
                <div>ãƒ¡ã‚¤ãƒ³</div>
            </div>
            <div class="mobile-nav-item" onclick="switchTab('scenes')">
                <div>ğŸ¬</div>
                <div>ã‚·ãƒ¼ãƒ³</div>
            </div>
            <div class="mobile-nav-item" onclick="switchTab('pages')">
                <div>ğŸ“„</div>
                <div>ãƒšãƒ¼ã‚¸</div>
            </div>
            <div class="mobile-nav-item" onclick="switchTab('dialogues')">
                <div>ğŸ’¬</div>
                <div>ã‚»ãƒªãƒ•</div>
            </div>
        </div>
    </nav>

    <script>
        let data = {
            scenes: [],
            pages: [],
            dialogues: []
        };
        
        let draggedElement = null;
        let draggedType = null;
        let draggedIndex = null;
        
        // DOMè¦ç´ ã®å–å¾—ï¼ˆå¾Œã§åˆæœŸåŒ–ï¼‰
        let mainEditor;
        let scenesContent;
        let pagesContent;
        let dialoguesContent;
        let scenesContainer;
        let pagesContainer;
        let dialoguesContainer;
        
        // å±¥æ­´ç®¡ç†
        let history = [];
        let historyIndex = -1;
        const maxHistory = 50;
        
        // å±¥æ­´ã‚’è¿½åŠ 
        function addToHistory(text) {
            // ç¾åœ¨ä½ç½®ã‚ˆã‚Šå¾Œã®å±¥æ­´ã‚’å‰Šé™¤
            history = history.slice(0, historyIndex + 1);
            
            // æ–°ã—ã„å±¥æ­´ã‚’è¿½åŠ 
            history.push(text);
            
            // æœ€å¤§å±¥æ­´æ•°ã‚’è¶…ãˆãŸã‚‰å¤ã„ã‚‚ã®ã‚’å‰Šé™¤
            if (history.length > maxHistory) {
                history.shift();
            }
            
            historyIndex = history.length - 1;
        }
        
        // å…ƒã«æˆ»ã™
        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                mainEditor.value = history[historyIndex];
                updateUI();
            }
        }
        
        // ã‚„ã‚Šç›´ã—
        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                mainEditor.value = history[historyIndex];
                updateUI();
            }
        }
        
        // ãƒ¢ãƒã‚¤ãƒ«ã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆ
        let currentTab = 'main';
        
        function switchTab(tabName) {
            currentTab = tabName;
            
            // ã™ã¹ã¦ã®ãƒšã‚¤ãƒ³ã‚’éè¡¨ç¤º
            document.getElementById('mainPane').style.display = 'none';
            document.getElementById('scenesPane').style.display = 'none';
            document.getElementById('pagesPane').style.display = 'none';
            document.getElementById('dialoguesPane').style.display = 'none';
            
            // é¸æŠã•ã‚ŒãŸãƒšã‚¤ãƒ³ã‚’è¡¨ç¤º
            switch(tabName) {
                case 'main':
                    document.getElementById('mainPane').style.display = 'flex';
                    break;
                case 'scenes':
                    document.getElementById('scenesPane').style.display = 'flex';
                    break;
                case 'pages':
                    document.getElementById('pagesPane').style.display = 'flex';
                    break;
                case 'dialogues':
                    document.getElementById('dialoguesPane').style.display = 'flex';
                    break;
            }
            
            // ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã‚’æ›´æ–°
            document.querySelectorAll('.mobile-nav-item').forEach(item => {
                item.classList.remove('active');
            });
            event.target.closest('.mobile-nav-item').classList.add('active');
        }
        
        // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒªã‚µã‚¤ã‚ºæ™‚ã®å‡¦ç†
        function handleResize() {
            if (window.innerWidth > 768) {
                // ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—è¡¨ç¤º
                document.getElementById('mainPane').style.display = 'flex';
                document.getElementById('scenesPane').style.display = 'flex';
                document.getElementById('pagesPane').style.display = 'flex';
                document.getElementById('dialoguesPane').style.display = 'flex';
            } else {
                // ãƒ¢ãƒã‚¤ãƒ«è¡¨ç¤º
                switchTab(currentTab);
            }
        }
        
        // DOMContentLoadedã§åˆæœŸåŒ–
        document.addEventListener('DOMContentLoaded', () => {
            mainEditor = document.getElementById('mainEditor');
            scenesContent = document.getElementById('scenesContent');
            pagesContent = document.getElementById('pagesContent');
            dialoguesContent = document.getElementById('dialoguesContent');
            scenesContainer = document.getElementById('scenesContainer');
            pagesContainer = document.getElementById('pagesContainer');
            dialoguesContainer = document.getElementById('dialoguesContainer');
            
            // åˆæœŸå±¥æ­´ã‚’è¿½åŠ 
            addToHistory(mainEditor.value);
            
            // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®š
            mainEditor.addEventListener('input', (e) => {
                updateUI();
                addToHistory(mainEditor.value);
            });
            
            // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ
            document.addEventListener('keydown', (e) => {
                if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                    e.preventDefault();
                    undo();
                } else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                    e.preventDefault();
                    redo();
                }
            });
            
            // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒªã‚µã‚¤ã‚ºã‚¤ãƒ™ãƒ³ãƒˆ
            window.addEventListener('resize', handleResize);
            
            // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«åŒæœŸã®è¨­å®š
            setupScrollSync();
            
            // åˆæœŸè¡¨ç¤º
            handleResize();
            updateUI();
        });
        
        // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«åŒæœŸã®è¨­å®š
        let isScrolling = false;
        
        function setupScrollSync() {
            [scenesContainer, pagesContainer, dialoguesContainer].forEach(container => {
                container.addEventListener('scroll', (e) => {
                    if (!isScrolling) {
                        isScrolling = true;
                        const scrollTop = e.target.scrollTop;
                        [scenesContainer, pagesContainer, dialoguesContainer].forEach(other => {
                            if (other !== e.target) {
                                other.scrollTop = scrollTop;
                            }
                        });
                        setTimeout(() => { isScrolling = false; }, 10);
                    }
                });
            });
        }
        
        // ãƒ†ã‚­ã‚¹ãƒˆã®ãƒ‘ãƒ¼ã‚¹
        function parseText(text) {
            const newData = {
                scenes: [],
                pages: [],
                dialogues: [],
                elements: [] // çµ±åˆã•ã‚ŒãŸè¦ç´ ãƒªã‚¹ãƒˆï¼ˆé«˜ã•è¨ˆç®—ç”¨ï¼‰
            };
            
            let currentTop = 10; // åˆæœŸãƒãƒ¼ã‚¸ãƒ³
            const itemMargin = 10; // ã‚¢ã‚¤ãƒ†ãƒ é–“ã®ãƒãƒ¼ã‚¸ãƒ³
            
            // ã‚·ãƒ¼ãƒ³ã®æŠ½å‡º
            const sceneRegex = /\{ã‚·ãƒ¼ãƒ³:\s*([^}]*)\}/g;
            let sceneMatch;
            let sceneIndex = 0;
            let globalPageNumber = 1;
            
            while ((sceneMatch = sceneRegex.exec(text)) !== null) {
                const sceneContent = sceneMatch[1];
                const sceneId = `scene-${sceneIndex}`;
                
                // ã‚·ãƒ¼ãƒ³ã®é–‹å§‹ä½ç½®
                const sceneTop = currentTop;
                
                // ã‚·ãƒ¼ãƒ³ã®ã¿ã®å†…å®¹ï¼ˆãƒšãƒ¼ã‚¸è¨˜æ³•ã‚’é™¤å¤–ï¼‰ã—ã¦è¡Œæ•°ã‚’è¨ˆç®—
                const sceneOnlyLines = sceneContent.split('\n').filter(line => !line.match(/^\[ãƒšãƒ¼ã‚¸:/));
                const sceneHeight = Math.max(100, sceneOnlyLines.length * 24 + 70);
                
                const sceneData = {
                    id: sceneId,
                    content: sceneContent,
                    fullMatch: sceneMatch[0],
                    startIndex: sceneMatch.index,
                    endIndex: sceneMatch.index + sceneMatch[0].length,
                    top: sceneTop,
                    height: sceneHeight,
                    pages: []
                };
                
                // ã‚·ãƒ¼ãƒ³å†…ã®ãƒšãƒ¼ã‚¸ã‚’æŠ½å‡º
                const pageRegex = /\[ãƒšãƒ¼ã‚¸:\s*([^\]]*)\]/g;
                let pageMatch;
                let pageTop = sceneTop; // æœ€åˆã®ãƒšãƒ¼ã‚¸ã¯ã‚·ãƒ¼ãƒ³ã¨åŒã˜é«˜ã•
                let maxPageBottom = sceneTop; // ãƒšãƒ¼ã‚¸ã®æœ€ä¸‹éƒ¨ã‚’è¿½è·¡
                
                while ((pageMatch = pageRegex.exec(sceneContent)) !== null) {
                    const pageContent = pageMatch[1];
                    const pageId = `page-${sceneIndex}-${sceneData.pages.length}`;
                    
                    // ãƒšãƒ¼ã‚¸å†…ã®ã‚»ãƒªãƒ•ã‚’æŠ½å‡º
                    const dialogues = [];
                    const dialogueRegex = /ã€Œ([^ã€]*)ã€/g;
                    let dialogueMatch;
                    
                    while ((dialogueMatch = dialogueRegex.exec(pageContent)) !== null) {
                        dialogues.push(dialogueMatch[1]);
                    }
                    
                    // ãƒšãƒ¼ã‚¸ã®é«˜ã•ã‚’è¨ˆç®—ï¼ˆæ”¹è¡Œã‚’å«ã‚€ï¼‰
                    const pageLines = pageContent.split('\n').length;
                    const pageHeight = Math.max(80, pageLines * 24 + 70);
                    
                    // ã‚»ãƒªãƒ•ã®é«˜ã•ã‚’è¨ˆç®—ï¼ˆã‚»ãƒªãƒ•å†…ã®æ”¹è¡Œã‚‚è€ƒæ…®ï¼‰
                    let totalDialogueLines = dialogues.length;
                    dialogues.forEach(d => {
                        totalDialogueLines += d.split('\n').length - 1;
                    });
                    const dialogueHeight = dialogues.length > 0 ? 
                        Math.max(80, 20 + totalDialogueLines * 40) : 80;
                    
                    // 2ã¤ç›®ä»¥é™ã®ãƒšãƒ¼ã‚¸ã¯å‰ã®ãƒšãƒ¼ã‚¸ã®ä¸‹ã«é…ç½®
                    if (sceneData.pages.length > 0) {
                        const lastPage = sceneData.pages[sceneData.pages.length - 1];
                        pageTop = lastPage.top + lastPage.pageHeight + itemMargin;
                    }
                    
                    const page = {
                        id: pageId,
                        content: pageContent,
                        sceneId: sceneId,
                        sceneIndex: sceneIndex,
                        dialogues: dialogues,
                        pageNumber: globalPageNumber++,
                        top: pageTop,
                        pageHeight: pageHeight,
                        dialogueHeight: dialogueHeight
                    };
                    
                    newData.pages.push(page);
                    sceneData.pages.push(page);
                    
                    // ã‚»ãƒªãƒ•ã‚’dialoguesã«è¿½åŠ 
                    newData.dialogues.push({
                        pageId: pageId,
                        sceneId: sceneId,
                        texts: dialogues,
                        top: pageTop,
                        height: dialogueHeight
                    });
                    
                    // æœ€ä¸‹éƒ¨ã‚’æ›´æ–°
                    maxPageBottom = pageTop + pageHeight;
                }
                
                // ãƒšãƒ¼ã‚¸ãŒãªã„å ´åˆã§ã‚‚æœ€å°é™ã®é«˜ã•ã‚’ç¢ºä¿
                if (sceneData.pages.length === 0) {
                    maxPageBottom = sceneTop + sceneHeight;
                }
                
                // ãƒšãƒ¼ã‚¸è¿½åŠ ãƒœã‚¿ãƒ³ã®ä½ç½®ã‚’è¨­å®šï¼ˆãƒšãƒ¼ã‚¸ã‚¿ãƒ–ã®æœ€ä¸‹éƒ¨ã«åŸºã¥ãï¼‰
                sceneData.addButtonTop = maxPageBottom + itemMargin;
                
                // æ¬¡ã®è¦ç´ ã®é–‹å§‹ä½ç½®ã‚’æ›´æ–°ï¼ˆã‚·ãƒ¼ãƒ³ã®é«˜ã•ã§ã¯ãªãã€ãƒšãƒ¼ã‚¸ã®æœ€ä¸‹éƒ¨ã«åŸºã¥ãï¼‰
                currentTop = sceneData.addButtonTop + 50 + itemMargin * 2;
                
                newData.scenes.push(sceneData);
                sceneIndex++;
            }
            
            // å…¨ä½“ã®é«˜ã•ã‚’è¨­å®š
            newData.totalHeight = currentTop + 100;
            
            return newData;
        }
        
        // UIã®æ›´æ–°
        function updateUI() {
            const text = mainEditor.value;
            data = parseText(text);
            
            // å„ã‚³ãƒ³ãƒ†ãƒŠã®é«˜ã•ã‚’è¨­å®š
            scenesContent.style.height = `${data.totalHeight}px`;
            pagesContent.style.height = `${data.totalHeight}px`;
            dialoguesContent.style.height = `${data.totalHeight}px`;
            
            // ã‚·ãƒ¼ãƒ³ã®è¡¨ç¤º
            updateScenes();
            
            // ãƒšãƒ¼ã‚¸ã®è¡¨ç¤º
            updatePages();
            
            // ã‚»ãƒªãƒ•ã®è¡¨ç¤º
            updateDialogues();
        }
        
        // ã‚·ãƒ¼ãƒ³ã®æ›´æ–°
        function updateScenes() {
            scenesContent.innerHTML = '';
            
            data.scenes.forEach((scene, index) => {
                const sceneItem = document.createElement('div');
                sceneItem.className = 'sync-item scene-item';
                sceneItem.style.top = `${scene.top}px`;
                sceneItem.style.height = `${scene.height}px`;
                
                sceneItem.innerHTML = `
                    <div class="scene-header">
                        <span class="scene-label">ã‚·ãƒ¼ãƒ³ ${index + 1}</span>
                        <button class="delete-button" onclick="deleteScene(${index})">å‰Šé™¤</button>
                    </div>
                    <div class="scene-content" contenteditable="true" data-index="${index}" data-type="scene">${textToHtml(scene.content)}</div>
                `;
                
                // ç·¨é›†ã‚¤ãƒ™ãƒ³ãƒˆ
                const contentDiv = sceneItem.querySelector('.scene-content');
                let isComposing = false;
                
                contentDiv.addEventListener('compositionstart', () => {
                    isComposing = true;
                });
                
                contentDiv.addEventListener('compositionend', () => {
                    isComposing = false;
                });
                
                contentDiv.addEventListener('input', (e) => {
                    if (!isComposing) {
                        const newContent = htmlToText(e.target.innerHTML);
                        updateSceneContent(index, newContent, false);
                    }
                });
                
                contentDiv.addEventListener('blur', (e) => {
                    const newContent = htmlToText(e.target.innerHTML);
                    updateSceneContent(index, newContent, true);
                });
                
                // æ”¹è¡Œå‡¦ç†
                contentDiv.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        document.execCommand('insertHTML', false, '\n');
                        
                        // é«˜ã•ã‚’å³åº§ã«æ›´æ–°
                        setTimeout(() => {
                            const newHeight = Math.max(100, contentDiv.scrollHeight + 70);
                            sceneItem.style.height = `${newHeight}px`;
                        }, 0);
                    }
                });
                
                scenesContent.appendChild(sceneItem);
            });
        }
        
        // ãƒšãƒ¼ã‚¸ã®æ›´æ–°
        function updatePages() {
            pagesContent.innerHTML = '';
            
            let currentSceneId = null;
            let sceneIndex = 0;
            
            data.pages.forEach((page, index) => {
                // æ–°ã—ã„ã‚·ãƒ¼ãƒ³ã®ãƒšãƒ¼ã‚¸ã‚°ãƒ«ãƒ¼ãƒ—ã®å ´åˆ
                if (page.sceneId !== currentSceneId) {
                    currentSceneId = page.sceneId;
                    sceneIndex = page.sceneIndex;
                }
                
                const pageItem = document.createElement('div');
                pageItem.className = 'sync-item page-item';
                pageItem.style.top = `${page.top}px`;
                pageItem.style.height = `${page.pageHeight}px`;
                
                pageItem.innerHTML = `
                    <div class="page-header">
                        <span class="page-label">ãƒšãƒ¼ã‚¸ ${page.pageNumber}</span>
                        <button class="delete-button" onclick="deletePage(${index})">å‰Šé™¤</button>
                    </div>
                    <div class="page-content" contenteditable="true" data-index="${index}" data-type="page">${textToHtml(page.content)}</div>
                `;
                
                // ç·¨é›†ã‚¤ãƒ™ãƒ³ãƒˆ
                const contentDiv = pageItem.querySelector('.page-content');
                let isComposing = false;
                
                contentDiv.addEventListener('compositionstart', () => {
                    isComposing = true;
                });
                
                contentDiv.addEventListener('compositionend', () => {
                    isComposing = false;
                });
                
                contentDiv.addEventListener('input', (e) => {
                    if (!isComposing) {
                        const newContent = htmlToText(e.target.innerHTML);
                        updatePageContent(index, newContent, false);
                        
                        // ãƒšãƒ¼ã‚¸ã®é«˜ã•ã‚’å‹•çš„ã«æ›´æ–°
                        const newHeight = Math.max(80, contentDiv.scrollHeight + 70);
                        pageItem.style.height = `${newHeight}px`;
                        
                        // ãƒœã‚¿ãƒ³ã®ä½ç½®ã‚’æ›´æ–°
                        updateButtonPositions();
                    }
                });
                
                contentDiv.addEventListener('blur', (e) => {
                    const newContent = htmlToText(e.target.innerHTML);
                    updatePageContent(index, newContent, true);
                });
                
                // æ”¹è¡Œå‡¦ç†
                contentDiv.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        document.execCommand('insertHTML', false, '\n');
                        
                        // é«˜ã•ã‚’å³åº§ã«æ›´æ–°
                        setTimeout(() => {
                            const newHeight = Math.max(80, contentDiv.scrollHeight + 70);
                            pageItem.style.height = `${newHeight}px`;
                            updateButtonPositions();
                        }, 0);
                    }
                });
                
                pagesContent.appendChild(pageItem);
            });
            
            // å„ã‚·ãƒ¼ãƒ³ã®ãƒšãƒ¼ã‚¸è¿½åŠ ãƒœã‚¿ãƒ³ã‚’é…ç½®
            data.scenes.forEach((scene, index) => {
                const addButton = document.createElement('button');
                addButton.className = 'add-page-button';
                addButton.dataset.sceneId = scene.id;
                addButton.style.top = `${scene.addButtonTop}px`;
                addButton.textContent = '+ ã“ã®ã‚·ãƒ¼ãƒ³ã«ãƒšãƒ¼ã‚¸ã‚’è¿½åŠ ';
                addButton.onclick = () => addPageToScene(scene.id, index);
                
                pagesContent.appendChild(addButton);
            });
        }
        
        // ãƒœã‚¿ãƒ³ä½ç½®ã®æ›´æ–°
        function updateButtonPositions() {
            const pageItems = pagesContent.querySelectorAll('.page-item');
            const buttons = pagesContent.querySelectorAll('.add-page-button');
            
            // å„ã‚·ãƒ¼ãƒ³ã”ã¨ã«ãƒœã‚¿ãƒ³ä½ç½®ã‚’è¨ˆç®—
            data.scenes.forEach((scene, sceneIndex) => {
                let maxBottom = scene.top;
                
                // ã“ã®ã‚·ãƒ¼ãƒ³ã«å±ã™ã‚‹ãƒšãƒ¼ã‚¸ã®æœ€ä¸‹éƒ¨ã‚’æ¤œç´¢
                data.pages.forEach((page, pageIndex) => {
                    if (page.sceneId === scene.id) {
                        const pageElement = pageItems[pageIndex];
                        if (pageElement) {
                            const pageBottom = parseInt(pageElement.style.top) + parseInt(pageElement.style.height);
                            maxBottom = Math.max(maxBottom, pageBottom);
                        }
                    }
                });
                
                // ãƒœã‚¿ãƒ³ã®ä½ç½®ã‚’æ›´æ–°
                buttons.forEach(button => {
                    if (button.dataset.sceneId === scene.id) {
                        button.style.top = `${maxBottom + 10}px`;
                    }
                });
            });
        }
        
        // ã‚»ãƒªãƒ•ã®æ›´æ–°
        function updateDialogues() {
            dialoguesContent.innerHTML = '';
            
            data.dialogues.forEach((dialogueGroup) => {
                const dialogueItem = document.createElement('div');
                dialogueItem.className = 'sync-item dialogue-item';
                dialogueItem.style.top = `${dialogueGroup.top}px`;
                dialogueItem.style.height = `${dialogueGroup.height}px`;
                
                dialogueItem.innerHTML = `
                    <div class="dialogue-content">
                        ${dialogueGroup.texts.length > 0 ? 
                            dialogueGroup.texts.map(text => `<div class="dialogue-text">${textToHtml(text)}</div>`).join('') :
                            '<div class="empty-dialogue">ã‚»ãƒªãƒ•ãŒã‚ã‚Šã¾ã›ã‚“</div>'
                        }
                    </div>
                `;
                
                dialoguesContent.appendChild(dialogueItem);
            });
        }
        
        // ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼
        function handleDragStart(e) {
            draggedElement = e.currentTarget;
            draggedType = e.currentTarget.dataset.type;
            draggedIndex = parseInt(e.currentTarget.dataset.index);
            e.currentTarget.classList.add('dragging');
        }
        
        function handleDragEnd(e) {
            e.currentTarget.classList.remove('dragging');
        }
        
        function handleDragOver(e) {
            e.preventDefault();
            const draggingOver = e.currentTarget;
            
            if (draggingOver !== draggedElement && draggingOver.dataset.type === draggedType) {
                draggingOver.classList.add('drag-over');
            }
        }
        
        function handleDragLeave(e) {
            e.currentTarget.classList.remove('drag-over');
        }
        
        function handleDrop(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('drag-over');
            
            const droppedOn = e.currentTarget;
            const droppedIndex = parseInt(droppedOn.dataset.index);
            
            if (draggedType === droppedOn.dataset.type && draggedIndex !== droppedIndex) {
                if (draggedType === 'scene') {
                    reorderScenes(draggedIndex, droppedIndex);
                } else if (draggedType === 'page') {
                    reorderPages(draggedIndex, droppedIndex);
                }
            }
        }
        
        // ã‚·ãƒ¼ãƒ³ã®ä¸¦ã³æ›¿ãˆ
        function reorderScenes(fromIndex, toIndex) {
            const text = mainEditor.value;
            const scenes = [...text.matchAll(/\{ã‚·ãƒ¼ãƒ³:\s*([^}]*)\}/g)];
            
            if (scenes[fromIndex] && scenes[toIndex]) {
                const sceneTexts = scenes.map(match => match[0]);
                const movedScene = sceneTexts.splice(fromIndex, 1)[0];
                sceneTexts.splice(toIndex, 0, movedScene);
                
                let newText = text;
                scenes.forEach((scene, index) => {
                    newText = newText.replace(scene[0], `###SCENE_${index}###`);
                });
                sceneTexts.forEach((sceneText, index) => {
                    newText = newText.replace(`###SCENE_${scenes.findIndex(s => s[0] === sceneText)}###`, sceneText);
                });
                
                mainEditor.value = newText;
                updateUI();
            }
        }
        
        // ãƒšãƒ¼ã‚¸ã®ä¸¦ã³æ›¿ãˆ
        function reorderPages(fromIndex, toIndex) {
            const pageData = data.pages[fromIndex];
            const targetPageData = data.pages[toIndex];
            
            if (pageData && targetPageData && pageData.sceneId === targetPageData.sceneId) {
                if (pageData.sceneId) {
                    const scene = data.scenes.find(s => s.id === pageData.sceneId);
                    const scenePages = data.pages.filter(p => p.sceneId === pageData.sceneId);
                    
                    const fromLocalIndex = scenePages.findIndex(p => p === pageData);
                    const toLocalIndex = scenePages.findIndex(p => p === targetPageData);
                    
                    reorderPagesInScene(scene, fromLocalIndex, toLocalIndex);
                }
            }
        }
        
        // ã‚·ãƒ¼ãƒ³å†…ã§ã®ãƒšãƒ¼ã‚¸ä¸¦ã³æ›¿ãˆ
        function reorderPagesInScene(scene, fromIndex, toIndex) {
            const text = mainEditor.value;
            const sceneMatch = text.match(new RegExp(`\\{ã‚·ãƒ¼ãƒ³:\\s*${escapeRegExp(scene.content)}\\}`));
            
            if (sceneMatch) {
                const sceneContent = sceneMatch[0];
                const pages = [...sceneContent.matchAll(/\[ãƒšãƒ¼ã‚¸:\s*([^\]]*)\]/g)];
                
                if (pages[fromIndex] && pages[toIndex]) {
                    const pageTexts = pages.map(match => match[0]);
                    const movedPage = pageTexts.splice(fromIndex, 1)[0];
                    pageTexts.splice(toIndex, 0, movedPage);
                    
                    let newSceneContent = sceneContent;
                    pages.forEach((page, index) => {
                        newSceneContent = newSceneContent.replace(page[0], `###PAGE_${index}###`);
                    });
                    pageTexts.forEach((pageText, index) => {
                        newSceneContent = newSceneContent.replace(`###PAGE_${pages.findIndex(p => p[0] === pageText)}###`, pageText);
                    });
                    
                    mainEditor.value = text.replace(sceneContent, newSceneContent);
                    updateUI();
                }
            }
        }
        
        // æ­£è¦è¡¨ç¾ã®ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
        function escapeRegExp(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }
        
        // ã‚·ãƒ¼ãƒ³å†…å®¹ã®æ›´æ–°
        function updateSceneContent(index, newContent, shouldUpdateUI = true) {
            const text = mainEditor.value;
            const scenes = [...text.matchAll(/\{ã‚·ãƒ¼ãƒ³:\s*([^}]*)\}/g)];
            
            if (scenes[index]) {
                const oldScene = scenes[index][0];
                const oldContent = scenes[index][1];
                // æœ«å°¾ã®æ”¹è¡Œã‚’ä¿æŒ
                const trimmedOldContent = oldContent.replace(/\n+$/, '');
                const trimmedNewContent = newContent.replace(/\n+$/, '');
                const trailingNewlines = oldContent.match(/\n*$/)[0];
                const newScene = oldScene.replace(oldContent, trimmedNewContent + trailingNewlines);
                
                const newText = text.replace(oldScene, newScene);
                mainEditor.value = newText;
                
                // ãƒ¡ã‚¤ãƒ³ã‚¿ãƒ–ã®å¤‰æ›´ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºç«
                mainEditor.dispatchEvent(new Event('input', { bubbles: true }));
                
                if (shouldUpdateUI) {
                    updateUI();
                }
            }
        }
        
        // ãƒšãƒ¼ã‚¸å†…å®¹ã®æ›´æ–°
        function updatePageContent(index, newContent, shouldUpdateUI = true) {
            const text = mainEditor.value;
            const allPages = [...text.matchAll(/\[ãƒšãƒ¼ã‚¸:\s*([^\]]*)\]/g)];
            
            let pageCount = 0;
            for (let match of allPages) {
                if (pageCount === index) {
                    const oldPage = match[0];
                    const oldContent = match[1];
                    // æœ«å°¾ã®æ”¹è¡Œã‚’ä¿æŒ
                    const trimmedOldContent = oldContent.replace(/\n+$/, '');
                    const trimmedNewContent = newContent.replace(/\n+$/, '');
                    const trailingNewlines = oldContent.match(/\n*$/)[0];
                    const newPage = oldPage.replace(oldContent, trimmedNewContent + trailingNewlines);
                    
                    const newText = text.replace(oldPage, newPage);
                    mainEditor.value = newText;
                    
                    // ãƒ¡ã‚¤ãƒ³ã‚¿ãƒ–ã®å¤‰æ›´ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºç«
                    mainEditor.dispatchEvent(new Event('input', { bubbles: true }));
                    
                    if (shouldUpdateUI) {
                        updateUI();
                    }
                    break;
                }
                pageCount++;
            }
        }
        
        // ã‚·ãƒ¼ãƒ³ã®å‰Šé™¤
        function deleteScene(index) {
            if (confirm('ã“ã®ã‚·ãƒ¼ãƒ³ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) {
                const text = mainEditor.value;
                const scenes = [...text.matchAll(/\{ã‚·ãƒ¼ãƒ³:\s*([^}]*)\}/g)];
                
                if (scenes[index]) {
                    mainEditor.value = text.replace(scenes[index][0], '');
                    updateUI();
                }
            }
        }
        
        // ãƒšãƒ¼ã‚¸ã®å‰Šé™¤
        function deletePage(index) {
            if (confirm('ã“ã®ãƒšãƒ¼ã‚¸ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) {
                const text = mainEditor.value;
                const allPages = [...text.matchAll(/\[ãƒšãƒ¼ã‚¸:\s*([^\]]*)\]/g)];
                
                let pageCount = 0;
                for (let match of allPages) {
                    if (pageCount === index) {
                        mainEditor.value = text.replace(match[0], '');
                        break;
                    }
                    pageCount++;
                }
                updateUI();
            }
        }
        
        // ã‚·ãƒ¼ãƒ³ã®è¿½åŠ 
        function addScene() {
            const newScene = '\n\n{ã‚·ãƒ¼ãƒ³: æ–°ã—ã„ã‚·ãƒ¼ãƒ³\n[ãƒšãƒ¼ã‚¸: æ–°ã—ã„ãƒšãƒ¼ã‚¸\nã€Œã‚»ãƒªãƒ•ã€\n]\n}';
            mainEditor.value += newScene;
            updateUI();
        }
        
        // ãƒšãƒ¼ã‚¸ã®è¿½åŠ ï¼ˆæ–°ã—ã„ã‚·ãƒ¼ãƒ³ã‚’è‡ªå‹•ç”Ÿæˆï¼‰
        function addPage() {
            const newScene = '\n\n{ã‚·ãƒ¼ãƒ³: æ–°ã—ã„ã‚·ãƒ¼ãƒ³\n[ãƒšãƒ¼ã‚¸: æ–°ã—ã„ãƒšãƒ¼ã‚¸\nã€Œã‚»ãƒªãƒ•ã€\n]\n}';
            mainEditor.value += newScene;
            updateUI();
        }
        
        // ç‰¹å®šã®ã‚·ãƒ¼ãƒ³ã«ãƒšãƒ¼ã‚¸ã‚’è¿½åŠ 
        function addPageToScene(sceneId, sceneIndex) {
            const text = mainEditor.value;
            const scenes = [...text.matchAll(/\{ã‚·ãƒ¼ãƒ³:\s*([^}]*)\}/g)];
            
            if (scenes[sceneIndex]) {
                const sceneMatch = scenes[sceneIndex];
                const sceneContent = sceneMatch[0];
                const newPage = '\n[ãƒšãƒ¼ã‚¸: æ–°ã—ã„ãƒšãƒ¼ã‚¸\nã€Œã‚»ãƒªãƒ•ã€\n]';
                const newSceneContent = sceneContent.replace(/\}$/, newPage + '\n}');
                
                mainEditor.value = text.replace(sceneContent, newSceneContent);
                updateUI();
            }
        }
        
        // ã‚»ãƒªãƒ•ã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆï¼ˆ1è¡Œé–‹ã‘ï¼‰
        function exportDialogues() {
            const allDialogues = [];
            data.dialogues.forEach(group => {
                allDialogues.push(...group.texts);
            });
            
            // å„ã‚»ãƒªãƒ•ã®é–“ã«ç©ºè¡Œã‚’å…¥ã‚Œã‚‹
            const dialogueText = allDialogues.join('\n\n');
            const blob = new Blob([dialogueText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'dialogues.txt';
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // ãƒ•ã‚¡ã‚¤ãƒ«ã®ä¿å­˜
        let currentFileName = null;
        
        function saveFile() {
            const text = mainEditor.value;
            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = currentFileName || 'tree-editor-document.txt';
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // æ–°è¦ä½œæˆ
        function newFile() {
            if (mainEditor.value && !confirm('ç¾åœ¨ã®å†…å®¹ã‚’ç ´æ£„ã—ã¦æ–°è¦ä½œæˆã—ã¾ã™ã‹ï¼Ÿ')) {
                return;
            }
            mainEditor.value = '';
            currentFileName = null;
            history = [''];
            historyIndex = 0;
            updateUI();
        }
        
        // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
        function openFile() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.txt';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        mainEditor.value = e.target.result;
                        currentFileName = file.name;
                        history = [e.target.result];
                        historyIndex = 0;
                        updateUI();
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }
        
        // ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‰ãƒ­ãƒƒãƒ—å‡¦ç†
        function handleFileDrop(e) {
            e.preventDefault();
            const file = e.dataTransfer.files[0];
            if (file && file.type === 'text/plain') {
                const reader = new FileReader();
                reader.onload = (e) => {
                    mainEditor.value = e.target.result;
                    currentFileName = file.name;
                    history = [e.target.result];
                    historyIndex = 0;
                    updateUI();
                };
                reader.readAsText(file);
            }
        }
        
        function handleDragOver(e) {
            e.preventDefault();
        }
        
        // HTMLã‚¨ã‚¹ã‚±ãƒ¼ãƒ—é–¢æ•°
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // ãƒ†ã‚­ã‚¹ãƒˆã‚’HTMLã«å¤‰æ›ï¼ˆæ”¹è¡Œã‚’<br>ã«ï¼‰
        function textToHtml(text) {
            return escapeHtml(text).replace(/\n/g, '<br>');
        }
        
        // HTMLã‚’ãƒ†ã‚­ã‚¹ãƒˆã«å¤‰æ›ï¼ˆ<br>ã‚’æ”¹è¡Œã«ï¼‰
        function htmlToText(html) {
            // <br>ã‚¿ã‚°ã‚’æ”¹è¡Œã«å¤‰æ›
            let text = html.replace(/<br\s*\/?>/gi, '\n');
            // divã‚¿ã‚°ã‚’æ”¹è¡Œã«å¤‰æ›ï¼ˆcontenteditableã§divãŒç”Ÿæˆã•ã‚Œã‚‹å ´åˆï¼‰
            text = text.replace(/<\/div><div>/gi, '\n');
            text = text.replace(/<div>/gi, '\n');
            text = text.replace(/<\/div>/gi, '');
            // ãã®ä»–ã®HTMLã‚¿ã‚°ã‚’å‰Šé™¤
            text = text.replace(/<[^>]*>/g, '');
            // HTMLã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚’ãƒ‡ã‚³ãƒ¼ãƒ‰
            const textarea = document.createElement('textarea');
            textarea.innerHTML = text;
            // å…ˆé ­ã®æ”¹è¡Œã‚’å‰Šé™¤ï¼ˆdivã‚¿ã‚°ã«ã‚ˆã‚‹ä½™åˆ†ãªæ”¹è¡Œï¼‰
            return textarea.value.replace(/^\n/, '');
        }
    </script>
</body>
</html>